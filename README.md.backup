# Rust Rule Engine v0.9.0 🦀⚡

[![Crates.io](https://img.shields.io/crates/v/rust-rule-engine.svg)](https://crates.io/crates/rust-rule-engine)
[![Documentation](https://docs.rs/rust-rule-engine/badge.svg)](https://docs.rs/rust-rule-engine)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Build Status](https://github.com/KSD-CO/rust-rule-engine/workflows/CI/badge.svg)](https://github.com/KSD-CO/rust-rule-engine/actions)
[![GitHub](https://img.shields.io/badge/GitHub-rust--rule--engine-blue?logo=github)](https://github.com/KSD-CO/rust-rule-engine)

## 🖥️ GRL Syntax Highlighting for VS Code

To make editing `.grl` rule files easier, install the [GRL Syntax Highlighting extension for VS Code](https://marketplace.visualstudio.com/items?itemName=tonthatvu.grl-syntax-highlighting&ssr=false#overview).

**Features:**
- Syntax highlighting for Grule Rule Language (GRL)
- Snippets for rule, action, function blocks
- Auto-detects `.grl` files

**Install:**
1. Open VS Code
2. Go to Extensions (`Ctrl+Shift+X`)
3. Search for `grl-syntax-highlighting` and install
4. Open or create `.grl` files to enjoy syntax highlighting

See [extension overview](https://marketplace.visualstudio.com/items?itemName=tonthatvu.grl-syntax-highlighting&ssr=false#overview) for more details.

A high-performance rule engine for Rust with **Plugin System**, **Built-in Utilities**, **GRL (Grule Rule Language) support**, and advanced pattern matching capabilities. Designed for production use with comprehensive error handling, type safety, and extensibility.

🔗 **[GitHub Repository](https://github.com/KSD-CO/rust-rule-engine)** | **[Documentation](https://docs.rs/rust-rule-engine)** | **[Crates.io](https://crates.io/crates/rust-rule-engine)**

## � Table of Contents

- [🚀 Key Features](#-key-features)
- [📦 Installation](#-installation)
- [🎯 Quick Start](#-quick-start)
  - [Basic Rule Engine with Built-in Plugins](#basic-rule-engine-with-built-in-plugins)
  - [Simple Rule without Plugins](#simple-rule-without-plugins)
- [🔌 Plugin System](#-plugin-system)
  - [Built-in Plugins Overview](#built-in-plugins-overview)
  - [Creating Custom Plugins](#creating-custom-plugins)
- [🎯 Advanced Features](#-advanced-features)
  - [Knowledge Base Management](#knowledge-base-management)
  - [Complex Data Objects](#complex-data-objects)
  - [Method Calls and Functions](#method-calls-and-functions)
  - [Error Handling and Debugging](#error-handling-and-debugging)
- [📚 Examples](#-examples)
- [🔧 Configuration](#-configuration)
  - [Engine Configuration](#engine-configuration)
  - [Plugin Configuration](#plugin-configuration)
- [🚀 Performance](#-performance)
- [🗺 Roadmap](#-roadmap)
- [🧩 Advanced Pattern Matching](#-advanced-pattern-matching-v070)
- [🎯 Rule Attributes](#-rule-attributes-v060)
- [🚨 Advanced Action Handlers](#-advanced-action-handlers-v071)
- [🌊 Advanced Workflow Engine](#-advanced-workflow-engine-v080-latest)
- [🤖 AI Integration](#-ai-integration-new)
- [🎨 Visual Rule Builder](#-visual-rule-builder-new)
- [🌐 REST API with Monitoring](#-rest-api-with-monitoring)
- [⚡ Performance & Architecture](#-performance--architecture)
- [🔧 RETE Algorithm Engine](#-rete-algorithm-engine-new)
- [📋 Changelog](#-changelog)
- [🎯 GRL Rule Language Features](#-grl-rule-language-features)
- [🌐 Distributed & Cloud Features](#-distributed--cloud-features)
- [📋 API Reference](#-api-reference)
- [🤝 Contributing](#-contributing)
- [📄 License](#-license)
- [🙏 Acknowledgments](#-acknowledgments)
- [📞 Support](#-support)

## �🚀 Key Features

### 🔥 **NEW in v0.9.0: Plugin System**
- **Modular Plugin Architecture**: Extensible plugin system with lifecycle management
- **Built-in Plugin Suite**: 44+ actions & 33+ functions for common operations
- **Plugin Health Monitoring**: Real-time health checks and status tracking
- **Hot-reload Support**: Dynamic plugin loading and unloading
- **Custom Plugin Creation**: Easy-to-use RulePlugin trait for custom extensions

### 🎯 **Core Engine Features**
- **GRL Support**: Full Grule-compatible syntax with method calls and object interactions
- **Knowledge Base**: Centralized rule management with salience and priority control
- **Working Memory**: Advanced facts system for complex data relationships
- **Type Safety**: Rust's type system ensures runtime safety and performance
- **High Performance**: Optimized execution with cycle detection and parallel processing
- **Flexible Facts API**: Support for nested objects, arrays, and complex data structures

### 🧩 **Advanced Pattern Matching**
- **EXISTS Pattern**: Check if at least one fact matches condition (`exists(...)`)
- **NOT Pattern**: Check if no facts match condition (`!exists(...)`)
- **FORALL Pattern**: Check if all facts of a type match condition (`forall(...)`)
- **Complex Patterns**: Combine patterns with logical operators (AND, OR, NOT)
- **Drools Compatibility**: ~85% compatible with Drools pattern matching

### 🔧 **RETE Algorithm Engine (NEW)**
- **RETE-UL Implementation**: High-performance pattern matching algorithm
- **Working Memory**: Drools-style fact management with FactHandles
- **Variable Binding**: Cross-pattern variable sharing with $var syntax
- **Incremental Updates**: Only re-evaluate affected rules (2x speedup)
- **Advanced Agenda**: Salience, activation groups, agenda groups
- **95% Drools Parity**: Compatible with Drools core features

### 🎯 **Rule Attributes & Workflow**
- **Agenda Groups**: Organize rules into execution phases for workflow control
- **Activation Groups**: Mutually exclusive rule execution with salience priority
- **Lock-on-Active**: Prevent rules from firing multiple times per agenda activation
- **Date Effective/Expires**: Time-based rule activation with DateTime support
- **No-Loop Protection**: Prevent infinite rule self-activation
- **Salience Control**: Priority-based rule execution ordering

### 🚨 **Action Handler System**
- **Custom Action Execution**: Register handlers for real business logic
- **Parameter Resolution**: Automatic fact value substitution in parameters
- **External System Integration**: Connect to emails, databases, APIs, services
- **Error Handling**: Graceful failure handling with meaningful messages
- **Facts Integration**: Full access to rule engine fact data within handlers

### 🌊 **Workflow Engine Features**
- **Scheduled Task System**: Time-based task execution with flexible scheduling
- **Workflow State Tracking**: Real-time workflow monitoring and progress tracking
- **Dynamic Rule Activation**: Context-aware rule execution based on workflow state
- **Comprehensive Analytics**: Detailed workflow performance metrics and insights

### 🛠 **Built-in Plugin Suite**
- **String Utilities**: 13 actions, 7 functions for text manipulation
- **Math Operations**: 12 actions, 8 functions for calculations
- **Date/Time**: 8 actions, 6 functions for temporal operations
- **Data Validation**: 6 actions, 6 functions for input validation
- **Collections**: 7 actions, 6 functions for array/object manipulation

### 🤖 **AI Integration**
- **Sentiment Analysis**: Real-time text sentiment evaluation
- **Fraud Detection**: ML-powered fraud scoring and detection
- **Predictive Analytics**: Customer tier prediction and scoring
- **LLM Reasoning**: Large Language Model decision support
- **Real-time ML Scoring**: Dynamic model inference in rules

### 🌐 **Production Features**
- **REST API**: Complete web API with analytics monitoring
- **Real-time Analytics**: Live performance monitoring and insights
- **Health Checks**: Comprehensive system health monitoring
- **CORS Support**: Cross-origin resource sharing
- **Memory Management**: Automatic cleanup and retention policies
- **Error Handling**: Proper HTTP status codes and error messages

### ⚡ **Performance & Architecture**

### 📊 Rule Coverage & Smart Testing (NEW)

Automatically measure which rules and conditions are covered by your test data, generate test cases for untested rules, and get detailed coverage reports in the console.

**Features:**
- Coverage analytics for all rules and conditions
- Auto-generation of test facts for uncovered rules
- Console report with warnings for untested rules
- Extensible for smart test case generation and analytics

**How to Use:**
1. Import the coverage module:
    ```rust
    use rust_rule_engine::engine::coverage::{RuleCoverage, generate_test_facts_for_rule};
    ```
2. After loading your rules, create a `RuleCoverage` instance:
    ```rust
    let coverage = RuleCoverage::new(&engine);
    ```
3. Run coverage analysis and print the report:
    ```rust
    coverage.report();
    ```
4. Auto-generate test facts for uncovered rules:
    ```rust
    let test_facts = generate_test_facts_for_rule(&rule);
    // Use these facts to test rule execution
    ```
5. Integrate with your test/demo code:
    ```rust
    // Example: Run coverage on a GRL rule demo
    let coverage = RuleCoverage::new(&engine);
    coverage.report();
    // Optionally, auto-generate and run test cases
    for rule in engine.rules() {
         let test_facts = generate_test_facts_for_rule(rule);
         // Execute rule with generated facts
    }
    ```

**Example Output:**
```text
Rule Coverage Report:
- Rule: "DiscountRule" [✔️ tested]
- Rule: "VIPUpgrade" [⚠️ not tested]
  → Warning: No test facts cover this rule
Test case auto-generation: 3 facts generated for rule "VIPUpgrade"
```

See `examples/grl_no_loop_demo.rs` and `src/engine/coverage.rs` for full usage.

## 📦 Installation

Add this to your `Cargo.toml`:

```toml
[dependencies]
rust-rule-engine = "0.9.0"
```

## 🎯 Quick Start

### Basic Rule Engine with Built-in Plugins

```rust
use rust_rule_engine::*;
use rust_rule_engine::engine::plugin::RulePlugin;
use rust_rule_engine::plugins::*;

fn main() -> Result<()> {
    // Create engine with knowledge base
    let kb = KnowledgeBase::new("Demo");
    let mut engine = RustRuleEngine::new(kb);
    let mut facts = Facts::new();

    // Load built-in plugins
    let string_plugin = StringUtilsPlugin::new();
    let math_plugin = MathUtilsPlugin::new();
    let validation_plugin = ValidationPlugin::new();

    // Register plugins
    string_plugin.register_actions(&mut engine)?;
    string_plugin.register_functions(&mut engine)?;
    math_plugin.register_actions(&mut engine)?;
    math_plugin.register_functions(&mut engine)?;
    validation_plugin.register_actions(&mut engine)?;
    validation_plugin.register_functions(&mut engine)?;

    // Set up data
    facts.set("user.email".to_string(), Value::String("user@example.com".to_string()));
    facts.set("user.age".to_string(), Value::Number(25.0));
    facts.set("order.amount".to_string(), Value::Number(150.0));

    // Define GRL rule with plugin actions
    let rule_content = r#"
    rule "UserValidationAndDiscount" salience 10 {
        when
            isEmail(user.email) == true &&
            inRange(user.age, 18, 65) == true &&
            user.order.amount > 100
        then
            ValidateEmail("user.email", "email_valid");
            ValidateRange("user.age", 18, 65, "age_valid");
            Multiply("order.amount", 0.9, "discounted_amount");
            ToUpperCase("user.status", "display_status");
    }
    "#;

    // Parse and add rule to knowledge base
    let rules = GRLParser::parse_rules(rule_content)?;
    for rule in rules {
        engine.add_rule_to_kb(rule)?;
    }

    // Execute rules
    let result = engine.execute(&facts)?;
    println!("Rules executed: {}", result.rules_executed);
    println!("Email valid: {:?}", facts.get("email_valid"));
    println!("Age valid: {:?}", facts.get("age_valid"));
    println!("Discounted amount: {:?}", facts.get("discounted_amount"));

    Ok(())
}
```

### Simple Rule without Plugins

```rust
use rust_rule_engine::*;

fn main() -> Result<()> {
    let kb = KnowledgeBase::new("SimpleDemo");
    let mut engine = RustRuleEngine::new(kb);
    let mut facts = Facts::new();

    // Set up facts
    facts.set("Customer.Age".to_string(), Value::Integer(25));
    facts.set("Customer.Country".to_string(), Value::String("US".to_string()));
    facts.set("Order.Total".to_string(), Value::Number(150.0));

    // Define GRL rule
    let rule = r#"
    rule "DiscountRule" salience 20 {
        when
            Customer.Age >= 18 && 
            Customer.Country == "US" && 
            Order.Total > 100
        then
            Order.DiscountRate = 0.15;
            Order.FreeShipping = true;
    }
    "#;

    // Parse and execute
    let rules = GRLParser::parse_rules(rule)?;
    for r in rules {
        engine.add_rule_to_kb(r)?;
    }

    let result = engine.execute(&facts)?;
    println!("Discount applied: {:?}", facts.get("Order.DiscountRate"));
    println!("Free shipping: {:?}", facts.get("Order.FreeShipping"));

    Ok(())
}
```

## 🔌 Plugin System

### Built-in Plugins Overview

The v0.9.0 release includes a comprehensive plugin suite:

#### 📝 String Utilities Plugin
```rust
// Actions: ToUpperCase, ToLowerCase, StringTrim, StringLength, 
//          StringContains, StringReplace, StringSplit, StringJoin
// Functions: concat, repeat, substring, padLeft, padRight

ToUpperCase("input_text", "output_text");
let result = concat("Hello", " World"); // "Hello World"
```

#### 🔢 Math Operations Plugin
```rust
// Actions: Add, Subtract, Multiply, Divide, Modulo, Power, Abs, Round, Ceil, Floor
// Functions: max, min, sqrt, sum, avg, random

Add("num1", "num2", "result");
let maximum = max(10.5, 8.2); // 10.5
```

#### 📅 Date/Time Plugin
```rust
// Actions: CurrentDate, CurrentTime, FormatDate, ParseDate, AddDays, AddHours, DateDiff, IsWeekend
// Functions: now, today, dayOfWeek, dayOfYear, year, month, day

CurrentDate("current_date");
let day = dayOfWeek("2023-10-15"); // Returns day number
```

#### ✅ Validation Plugin
```rust
// Actions: ValidateEmail, ValidatePhone, ValidateUrl, ValidateRegex, ValidateRange, ValidateLength, ValidateNotEmpty, ValidateNumeric
// Functions: isEmail, isPhone, isUrl, isNumeric, isEmpty, inRange

ValidateEmail("user.email", "email_valid");
let valid = isEmail("test@example.com"); // true
```

#### 📋 Collection Operations Plugin
```rust
// Actions: ArrayLength, ArrayPush, ArrayPop, ArraySort, ArrayFilter, ArrayMap, ArrayFind, ObjectKeys, ObjectValues, ObjectMerge
// Functions: length, contains, first, last, reverse, join, slice, keys, values

ArrayLength("my_array", "array_length");
let size = length([1, 2, 3, 4]); // 4
```

### Creating Custom Plugins

```rust
use rust_rule_engine::engine::plugin::{RulePlugin, PluginMetadata, PluginState, PluginHealth};

pub struct MyCustomPlugin {
    metadata: PluginMetadata,
}

impl MyCustomPlugin {
    pub fn new() -> Self {
        Self {
            metadata: PluginMetadata {
                name: "my_custom_plugin".to_string(),
                version: "1.0.0".to_string(),
                description: "My custom plugin".to_string(),
                author: "Developer Name".to_string(),
                state: PluginState::Loaded,
                health: PluginHealth::Healthy,
                actions: vec!["MyAction".to_string()],
                functions: vec!["myFunction".to_string()],
                dependencies: vec![],
            },
        }
    }
}

impl RulePlugin for MyCustomPlugin {
    fn get_metadata(&self) -> &PluginMetadata {
        &self.metadata
    }

    fn register_actions(&self, engine: &mut RustRuleEngine) -> Result<()> {
        engine.register_action_handler("MyAction", |params, facts| {
            // Your custom action logic here
            Ok(())
        });
        Ok(())
    }

    fn register_functions(&self, engine: &mut RustRuleEngine) -> Result<()> {
        engine.register_function("myFunction", |args, _facts| {
            // Your custom function logic here
            Ok(Value::String("result".to_string()))
        });
        Ok(())
    }

    fn unload(&mut self) -> Result<()> {
        self.metadata.state = PluginState::Unloaded;
        Ok(())
    }

    fn health_check(&mut self) -> PluginHealth {
        PluginHealth::Healthy
    }
}
```

## 🎯 Advanced Features

### Knowledge Base Management

```rust
let mut kb = KnowledgeBase::new("Advanced");

// Add rules with different salience (priority)
kb.add_rule_from_grl(r#"
rule "HighPriority" salience 100 { when condition then action }
"#)?;

kb.add_rule_from_grl(r#"
rule "LowPriority" salience 10 { when condition then action }
"#)?;

// Rules execute in salience order (highest first)
let mut engine = RustRuleEngine::new(kb);
```

### Complex Data Objects

```rust
use std::collections::HashMap;

let mut facts = Facts::new();

// Nested object structures
let mut customer = HashMap::new();
customer.insert("name".to_string(), Value::String("John Doe".to_string()));
customer.insert("age".to_string(), Value::Integer(30));

let mut address = HashMap::new();
address.insert("country".to_string(), Value::String("US".to_string()));
address.insert("state".to_string(), Value::String("CA".to_string()));

customer.insert("address".to_string(), Value::Object(address));
facts.set("Customer".to_string(), Value::Object(customer));

// Access nested properties in rules
let rule = r#"
rule "LocationRule" {
    when
        Customer.address.country == "US" &&
        Customer.address.state == "CA" &&
        Customer.age >= 21
    then
        Customer.eligible = true;
        Customer.discount = 0.1;
}
"#;
```

### Method Calls and Functions

```rust
// Built-in functions in conditions
let rule = r#"
rule "ValidationRule" {
    when
        isEmail(Customer.email) == true &&
        length(Customer.name) > 2 &&
        inRange(Customer.age, 18, 120) == true
    then
        Customer.validated = true;
}
"#;

// Custom function registration
engine.register_function("customValidation", |args, facts| {
    // Custom validation logic
    Ok(Value::Boolean(true))
});
```

### Error Handling and Debugging

```rust
use rust_rule_engine::errors::{Result, RuleEngineError};

// Comprehensive error handling
match engine.execute(&facts) {
    Ok(result) => {
        println!("Success: {} rules executed", result.rules_executed);
        println!("Execution time: {:?}", result.execution_time);
    },
    Err(RuleEngineError::ParseError { message, line, column }) => {
        eprintln!("Parse error at {}:{} - {}", line, column, message);
    },
    Err(RuleEngineError::EvaluationError { message }) => {
        eprintln!("Evaluation error: {}", message);
    },
    Err(e) => {
        eprintln!("Other error: {}", e);
    }
}
```

## 📚 Examples

The repository includes comprehensive examples:

- **Basic Usage**: `examples/basic_demo.rs`
- **Plugin System**: `examples/builtin_plugins_demo.rs`
- **E-commerce Rules**: `examples/ecommerce.rs`
- **Fraud Detection**: `examples/fraud_detection.rs`
- **GRL Compatibility**: `examples/grule_demo.rs`
- **Streaming Data**: `examples/realtime_trading_stream.rs`

Run examples:
```bash
cargo run --example builtin_plugins_demo
cargo run --example ecommerce
cargo run --example fraud_detection
```

## 🔧 Configuration

### Engine Configuration

```rust
use rust_rule_engine::engine::engine::EngineConfig;

let config = EngineConfig {
    max_cycles: 1000,
    enable_tracing: true,
    parallel_execution: true,
    cycle_detection: true,
};

let engine = RustRuleEngine::with_config(kb, config);
```

### Plugin Configuration

```rust
use rust_rule_engine::engine::plugin::{PluginConfig, PluginManager};

let plugin_config = PluginConfig {
    max_plugins: 50,
    enable_hot_reload: true,
    plugin_timeout_ms: 5000,
    safety_checks: true,
};

let plugin_manager = PluginManager::new(plugin_config);
```

## 🚀 Performance

Rust Rule Engine v0.9.0 is designed for high-performance scenarios:

- **Zero-copy**: Efficient memory usage with minimal allocations
- **Parallel Execution**: Multi-threaded rule processing when safe
- **Optimized Parsing**: Fast GRL parsing with minimal overhead
- **Plugin Caching**: Efficient plugin management and reuse
- **Cycle Detection**: Prevents infinite loops in rule chains

## 🗺 Roadmap

### v0.10.0 (Planned)
- [ ] **Advanced Plugin Features**
  - Plugin dependency management
  - Plugin versioning and compatibility
  - Plugin marketplace integration
- [ ] **Performance Enhancements**
  - Rule compilation to bytecode
  - Advanced caching strategies
  - Memory pool optimization
- [ ] **Developer Experience**
  - Visual rule debugger
  - Rule testing framework
  - IDE plugins and syntax highlighting

### v1.0.0 (Future)
- [ ] **Production Features**
  - Distributed rule execution
  - Rule versioning and migration
  - Advanced monitoring and metrics
- [ ] **Enterprise Features**
  - Role-based access control
  - Audit logging
  - Integration with external systems

## 🤝 Contributing

We welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

### Development Setup

```bash
git clone https://github.com/KSD-CO/rust-rule-engine.git
cd rust-rule-engine
cargo build
cargo test
cargo run --example builtin_plugins_demo
```

### Running Tests

```bash
# Run all tests
cargo test

# Run with coverage
cargo test --features coverage

# Run benchmarks
cargo bench
```

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- Inspired by [Grule](https://github.com/hyperjumptech/grule-rule-engine) rule engine
- Built with Rust's powerful type system and performance capabilities
- Community feedback and contributions

## 📞 Support

- 📚 [Documentation](https://docs.rs/rust-rule-engine)
- 🐛 [Issue Tracker](https://github.com/KSD-CO/rust-rule-engine/issues)
- 💬 [Discussions](https://github.com/KSD-CO/rust-rule-engine/discussions)
- 📧 Email: tonthatvu.hust@gmail.com

---

**Rust Rule Engine v0.9.0** - Powerful, extensible, and production-ready rule engine for Rust 🦀⚡
- **🌊 Stream Processing**: Real-time event processing with time windows (optional)
- **📊 Analytics**: Built-in aggregations and trend analysis
- **🚨 Action Handlers**: Custom action execution for external system integration
- **📈 Advanced Analytics**: Production-ready performance monitoring and optimization insights

## 🌊 Advanced Workflow Engine v0.8.0 (Latest!)

The rule engine now features a **comprehensive workflow engine** with agenda group management, scheduled task execution, and real-time workflow state tracking for complex business process automation.

### Workflow Features

- **📋 Agenda Group Management**: Organize rules into execution phases with automatic transitions
- **⏰ Scheduled Task System**: Time-based task execution with flexible scheduling
- **🔄 Workflow State Tracking**: Real-time workflow monitoring and progress tracking
- **🎯 Dynamic Rule Activation**: Context-aware rule execution based on workflow state
- **� Comprehensive Analytics**: Detailed workflow performance metrics and insights

### Workflow Example

```rust
use rust_rule_engine::engine::{RustRuleEngine, EngineConfig};
use rust_rule_engine::engine::knowledge_base::KnowledgeBase;
use rust_rule_engine::parser::grl::GRLParser;
use rust_rule_engine::types::Value;
use rust_rule_engine::Facts;

// Create workflow engine
let config = EngineConfig {
    debug_mode: false,
    max_cycles: 100,
    enable_stats: true,
    ..Default::default()
};
let mut engine = RustRuleEngine::with_config(KnowledgeBase::new("WorkflowDemo"), config);

// Define workflow rules with agenda groups
let workflow_rules = vec![
    r#"
    rule "StartOrderWorkflow" salience 100 agenda-group "start" {
        when Order.Status == "pending"
        then
            log("🔄 Starting order processing workflow");
            ActivateAgendaGroup("validation");
            SetWorkflowData("order-process", status="started");
    }
    "#,
    r#"
    rule "ValidateOrder" salience 90 agenda-group "validation" {
        when Order.Amount > 0 && Inventory.Available == true
        then
            log("✅ Order validation passed");
            Order.Status = "validated";
            ActivateAgendaGroup("payment");
    }
    "#,
    r#"
    rule "ProcessVIPPayment" salience 80 agenda-group "payment" {
        when Order.Status == "validated" && Customer.VIP == true
        then
            log("💳 Processing VIP payment with priority");
            Order.Status = "paid";
            ActivateAgendaGroup("fulfillment");
    }
    "#
];

// Execute workflow with automatic agenda management
let result = engine.execute_workflow(&facts)?;
println!("Workflow completed: {} rules fired in {} cycles", 
         result.rules_fired, result.cycles);
```

## 🚨 Advanced Action Handlers v0.7.1

The rule engine now supports advanced custom action execution with **simplified parameter syntax** and **automatic fact resolution**, enabling seamless integration with external systems.

### Action Handler System

Register custom handlers for `ActionType::Custom` actions that can execute real business logic instead of just debug printing.

#### ✨ Simplified Parameter Syntax v0.7.1

```rust
use rust_rule_engine::engine::{RustRuleEngine, EngineConfig};
use rust_rule_engine::types::Value;
use std::collections::HashMap;

// Create engine
let mut engine = RustRuleEngine::with_config(kb, EngineConfig::default());

// Register email handler with indexed parameters
engine.register_action_handler("SendEmail", |params, facts| {
    // Access parameters by index: "0", "1", "2"...
    let to = if let Some(arg) = params.get("0") {
        match arg {
            Value::String(s) => {
                // Automatic fact resolution: Customer.email → alice@example.com
                if let Some(resolved) = facts.get_nested(s) {
                    resolved.to_string()
                } else {
                    s.clone()
                }
            }
            _ => arg.to_string(),
        }
    } else {
        "unknown@example.com".to_string()
    };
    
    let subject = params.get("1").map(|v| v.to_string()).unwrap_or("No Subject".to_string());
    let body = params.get("2").map(|v| v.to_string()).unwrap_or("No Body".to_string());
    
    // Execute actual email sending logic
    println!("📧 EMAIL SENT:");
    println!("   To: {}", to);
    println!("   Subject: {}", subject);
    println!("   Body: {}", body);
    
    Ok(())
});

// Register database logger with simplified syntax
engine.register_action_handler("LogToDatabase", |params, facts| {
    let table = params.get("0").map(|v| v.to_string()).unwrap_or("default_table".to_string());
    let event = params.get("1").map(|v| v.to_string()).unwrap_or("unknown_event".to_string());
    
    println!("🗄️ DATABASE LOG:");
    println!("   Table: {}", table);
    println!("   Event: {}", event);
    println!("   Timestamp: {}", chrono::Utc::now().format("%Y-%m-%d %H:%M:%S"));
    
    Ok(())
});
```

#### Parameter Resolution

Action handlers automatically resolve fact references in parameters:

```rust
// In GRL rule:
rule "WelcomeCustomer" {
    when
        Customer.status == "new"
    then
        SendEmail(Customer.email, "Welcome!", Customer.name);
}

// Parameter resolution in action:
// Parameter 0: "Customer.email" → "john.doe@example.com"
// Parameter 1: "Welcome!" → "Welcome!"
// Parameter 2: "Customer.name" → "John Doe"
```

#### GRL Usage with Action Handlers

```grl
rule "VIPCustomerWelcome" salience 20 no-loop {
    when
        Customer.tier == "VIP" && Customer.welcome_sent != true
    then
        SendEmail(Customer.email, "VIP Welcome Package", "Welcome to our VIP program!");
        LogToDatabase("customer_events", "vip_welcome_sent");
        Customer.welcome_sent = true;
}

rule "HighValueOrderAlert" salience 15 no-loop {
    when
        Order.total > 5000 && Order.alert_sent != true
    then
        SendAlert("HIGH", "High-value order requires review");
        ProcessPayment(Order.total, "secure_processing");
        Order.alert_sent = true;
}
```

### Action Handler Examples

See complete examples:
- [Action Handlers Demo](examples/action_handlers_demo.rs) - Comprehensive action handler showcase

### Benefits

✅ **External System Integration**: Connect rules to emails, databases, APIs, services  
✅ **Real Business Logic**: Execute actual business operations, not just debug prints  
✅ **Parameter Resolution**: Automatic fact value substitution in action parameters  
✅ **Facts Integration**: Full access to rule engine fact data within handlers  
✅ **Error Handling**: Graceful failure handling with meaningful error messages  
✅ **Performance**: Efficient execution with minimal overhead  
✅ **Flexibility**: Register any custom business logic as action handlers  
✅ **Testability**: Mock handlers for unit testing rule behavior  

## 🧩 Advanced Pattern Matching v0.7.0

The rule engine now supports advanced pattern matching capabilities similar to Drools, enabling complex conditional logic with EXISTS, NOT, and FORALL patterns.

### Pattern Types

#### EXISTS Pattern
Check if **at least one** fact matches the condition:

```rust
// Programmatic API
let condition = ConditionGroup::exists(
    ConditionGroup::Single(Condition::new(
        "Customer.tier".to_string(),
        Operator::Equal,
        Value::String("VIP".to_string()),
    ))
);
```

```grl
// GRL Syntax
rule "ActivateVIPService" salience 20 {
    when
        exists(Customer.tier == "VIP")
    then
        System.vipServiceActive = true;
        log("VIP service activated");
}
```

#### NOT Pattern
Check if **no facts** match the condition:

```rust
// Programmatic API
let condition = ConditionGroup::not(
    ConditionGroup::exists(
        ConditionGroup::Single(Condition::new(
            "Order.status".to_string(),
            Operator::Equal,
            Value::String("pending".to_string()),
        ))
    )
);
```

```grl
// GRL Syntax
rule "SendMarketingEmail" salience 15 {
    when
        !exists(Order.status == "pending")
    then
        Marketing.emailSent = true;
        log("Marketing email sent - no pending orders");
}
```

#### FORALL Pattern
Check if **all facts** of a type match the condition:

```rust
// Programmatic API  
let condition = ConditionGroup::forall(
    ConditionGroup::Single(Condition::new(
        "Order.status".to_string(),
        Operator::Equal,
        Value::String("processed".to_string()),
    ))
);
```

```grl
// GRL Syntax
rule "EnableShipping" salience 10 {
    when
        forall(Order.status == "processed")
    then
        Shipping.enabled = true;
        log("All orders processed - shipping enabled");
}
```

#### Combined Patterns
Combine multiple patterns with logical operators:

```grl
rule "ComplexBusinessRule" salience 25 {
    when
        exists(Customer.tier == "VIP") && 
        !exists(Alert.priority == "high") &&
        forall(Order.status == "processed")
    then
        System.premiumModeEnabled = true;
        log("Premium mode activated - all conditions met");
}
```

### Pattern Matching Examples

See complete examples:
- [Pattern Matching Demo](examples/pattern_matching_demo.rs) - Programmatic API
- [GRL Pattern Matching Demo](examples/simple_pattern_matching_grl.rs) - GRL file syntax
- [Complex Patterns from File](examples/pattern_matching_from_grl.rs) - Advanced GRL patterns

### Drools Compatibility

Pattern matching brings ~85% compatibility with Drools rule engine, supporting the core pattern matching features that enable complex business logic modeling.

## 🎯 Rule Attributes v0.6.0

Advanced rule attributes providing **Drools-compatible** workflow control and execution management:

### 📋 Agenda Groups - Workflow Control
Organize rules into **execution phases** with agenda group control:

```grl
rule "ValidateCustomer" agenda-group "validation" salience 10 {
    when
        Customer.age >= 18
    then
        Customer.status = "valid";
        log("Customer validated");
}

rule "ProcessPayment" agenda-group "processing" salience 5 {
    when
        Customer.status == "valid"
    then
        Order.status = "processed";
        log("Payment processed");
}
```

```rust
// Control workflow execution
engine.set_agenda_focus("validation");
engine.execute(&facts)?; // Only validation rules fire

engine.set_agenda_focus("processing"); 
engine.execute(&facts)?; // Only processing rules fire
```

### 🎯 Activation Groups - Mutually Exclusive Rules
Ensure **only one rule** from a group fires:

```grl
rule "PremiumDiscount" activation-group "discount" salience 10 {
    when Customer.tier == "premium"
    then Order.discount = 0.20;
}

rule "GoldDiscount" activation-group "discount" salience 8 {
    when Customer.tier == "gold"  
    then Order.discount = 0.15;
}
```

### 🔒 Lock-on-Active - One-time Execution
Prevent rules from firing again until agenda group changes:

```grl
rule "WelcomeEmail" lock-on-active salience 10 {
    when Customer.isNew == true
    then sendWelcomeEmail(Customer);
}
```

### ⏰ Date Effective/Expires - Time-based Rules
Create **seasonal** or **time-limited** rules:

```grl
rule "ChristmasDiscount" 
    date-effective "2025-12-01T00:00:00Z"
    date-expires "2025-12-31T23:59:59Z" 
    salience 20 {
    when Order.total > 100
    then Order.seasonalDiscount = 0.25;
}
```

### 🔄 Combined Attributes - Complex Rules
Mix multiple attributes for sophisticated control:

```grl
rule "ComplexPaymentRule"
    agenda-group "processing"
    activation-group "payment"
    lock-on-active
    no-loop
    salience 30 {
    when
        Order.status == "pending" && Payment.method == "credit"
    then
        Order.status = "processed";
        Payment.confirmed = true;
}
```

### 📊 Programmatic API
Use attributes with the Rust API:

```rust
let rule = Rule::new("MyRule", conditions, actions)
    .with_agenda_group("validation".to_string())
    .with_activation_group("discount".to_string())
    .with_lock_on_active(true)
    .with_date_effective_str("2025-12-01T00:00:00Z")?
    .with_date_expires_str("2025-12-31T23:59:59Z")?;

// Get available groups
let agenda_groups = engine.get_agenda_groups();
let activation_groups = engine.get_activation_groups();

// Workflow control
engine.set_agenda_focus("validation");
engine.execute(&facts)?;
```

## 🤖 AI Integration (NEW!)

Integrate AI/ML models seamlessly into your rules, similar to **Drools Pragmatic AI**:

### Features
- **🤖 Sentiment Analysis**: Real-time text sentiment evaluation
- **🛡️ Fraud Detection**: ML-powered fraud scoring and detection
- **🏆 Predictive Analytics**: Customer tier prediction and scoring
- **🧠 LLM Reasoning**: Large Language Model decision support
- **📊 Real-time ML Scoring**: Dynamic model inference in rules

### Example AI Rules

```grl
rule "AI Customer Service" salience 100 {
    when
        CustomerMessage.type == "complaint"
    then
        analyzeSentiment(CustomerMessage.text);
        set(Ticket.priority, "high");
        logMessage("🤖 AI analyzing customer sentiment");
}

rule "AI Fraud Detection" salience 90 {
    when
        Transaction.amount > 1000
    then
        detectFraud(Transaction.amount, Transaction.userId);
        set(Transaction.status, "under_review");
        sendNotification("🛡️ Checking for potential fraud", "security@company.com");
}

rule "AI Tier Prediction" salience 80 {
    when
        Customer.tier == "pending"
    then
        predictTier(Customer.id);
        set(Customer.tierAssignedBy, "AI");
        logMessage("🏆 AI predicting customer tier");
}
```

### Register AI Functions

```rust
// Register AI-powered functions
engine.register_function("analyzeSentiment", |args, _facts| {
    let text = args[0].as_string().unwrap_or("".to_string());
    
    // Call actual AI API (OpenAI, Anthropic, Hugging Face, etc.)
    let rt = tokio::runtime::Runtime::new().unwrap();
    let sentiment = rt.block_on(async {
        call_openai_sentiment_api(&text).await
    }).unwrap_or_else(|_| "neutral".to_string());
    
    Ok(Value::String(sentiment))
});

engine.register_function("detectFraud", |args, facts| {
    let amount = args[0].as_number().unwrap_or(0.0);
    let user_id = args[1].as_string().unwrap_or("unknown".to_string());
    
    // Call actual ML fraud detection API
    let rt = tokio::runtime::Runtime::new().unwrap();
    let is_fraud = rt.block_on(async {
        call_fraud_detection_api(amount, &user_id, facts).await
    }).unwrap_or_else(|_| false);
    
    Ok(Value::Boolean(is_fraud))
});

engine.register_function("predictTier", |args, facts| {
    let customer_id = args[0].as_string().unwrap_or("unknown".to_string());
    
    // Call actual ML tier prediction API
    let rt = tokio::runtime::Runtime::new().unwrap();
    let predicted_tier = rt.block_on(async {
        call_tier_prediction_api(&customer_id, facts).await
    }).unwrap_or_else(|_| "bronze".to_string());
    
    Ok(Value::String(predicted_tier))
});
```

## 📋 Changelog

### v0.8.0 (October 2025) - Advanced Workflow Engine Implementation 🌊
- **🌊 Advanced Workflow Engine**: Complete workflow management system with comprehensive features
  - **📋 Agenda Group Management**: Organize rules into execution phases with automatic focus transitions
  - **⏰ Scheduled Task System**: Time-based task execution with flexible scheduling and conditional triggers
  - **🔄 Workflow State Tracking**: Real-time workflow monitoring with start/complete lifecycle management
  - **🎯 Dynamic Agenda Activation**: Context-aware agenda group activation based on workflow state
  - **📊 Workflow Analytics**: Detailed performance metrics including execution statistics and task monitoring
  - **🚀 Seamless Integration**: Unified API combining rule execution with workflow orchestration
- **🔧 Enhanced Rule Engine**: Improved fact handling and condition evaluation
  - **Facts API Enhancement**: Extended Facts system with workflow data integration
  - **Condition Evaluation**: Optimized condition processing with better error handling
  - **Action Processing**: Enhanced action execution with workflow context awareness
- **🧪 Comprehensive Demos**: Real-world workflow examples
  - Basic order processing workflow with VIP customer routing
  - Advanced workflow with scheduled tasks and multi-phase execution
  - Complete workflow lifecycle demonstrations with detailed logging
- **🛡️ Production Ready**: Enhanced error handling and performance optimization for workflow scenarios

### v0.7.1 (October 2025) - Advanced Action Handlers Implementation 🚨
- **🚨 Advanced Action Handlers**: Custom action execution system for external integrations
  - **Action Handler Registry**: Register custom handlers for `ActionType::Custom` execution
  - **Parameter Resolution**: Automatic fact value substitution in action parameters
  - **Facts Integration**: Full access to fact data within action handlers
  - **Error Handling**: Graceful failure handling with meaningful error messages
  - **Built-in Handler Examples**: Email, database logging, alerts, payment processing
- **🔧 Enhanced Custom Actions**: Fix `ActionType::Custom` from debug-only to fully functional
  - Previously: `ActionType::Custom` only printed debug messages
  - Now: Executes registered business logic handlers with real functionality
- **⚡ Parameter Resolution Engine**: Smart fact reference resolution in action parameters
  - `"Customer.email"` → resolves to actual email value from facts
  - `"Order.total"` → resolves to actual order total amount
  - Supports nested fact path resolution with dot notation
- **🧪 Comprehensive Demo**: Real-world action handler examples
  - Email sending with template parameters
  - Database event logging with fact context
  - Multi-level alert system (INFO, HIGH, CRITICAL)
  - Payment processing with business rule validation
- **🛡️ No-Loop Protection**: Enhanced rule execution control for action-triggered rules

### v0.7.0 (October 2025) - Advanced Pattern Matching & Drools Compatibility 🧩
- **🧩 Advanced Pattern Matching**: Complete implementation of EXISTS, NOT, and FORALL patterns
  - **EXISTS pattern**: Check if at least one fact matches condition
  - **NOT pattern**: Check if no facts match condition (using `!exists(...)`)
  - **FORALL pattern**: Check if all facts of a type match condition
  - **Complex patterns**: Combine patterns with logical operators (AND, OR, NOT)
- **🎯 GRL Syntax Support**: Full pattern matching support in GRL files
  - `exists(Customer.tier == "VIP")` syntax for existence checking
  - `!exists(Order.status == "pending")` syntax for non-existence
  - `forall(Order.status == "processed")` syntax for universal quantification
  - Combined patterns: `exists(...) && !exists(...) && forall(...)`
- **🔧 Parser Extensions**: Enhanced GRL parser with pattern matching keywords
  - Recursive pattern parsing with proper parentheses handling
  - Seamless integration with existing logical operators
  - Comprehensive parser tests for all pattern types
- **⚡ Pattern Evaluation Engine**: High-performance pattern matching evaluation
  - Smart fact type detection and mapping (e.g., Customer1 → Customer)
  - Efficient fact iteration and filtering algorithms
  - Full backward compatibility with existing rule engine
- **🧪 Comprehensive Testing**: Full test coverage for pattern matching features
  - 4 dedicated pattern matcher unit tests (all passing)
  - Real-world business scenario demonstrations
  - GRL file parsing and execution integration tests
  - Multiple example files showcasing pattern matching capabilities

### v0.6.0 (October 2025) - Rule Attributes Enhancement 🎯
- **🎯 Comprehensive Rule Attributes**: Drools-compatible rule attributes system
  - **📋 Agenda Groups**: Structured workflow control with focus management
  - **🔒 Activation Groups**: Mutually exclusive rule execution with salience priority
  - **🔒 Lock-on-Active**: Prevent rules from firing multiple times per agenda activation
  - **⏰ Date Effective/Expires**: Time-based rule activation with DateTime support
  - **📊 Programmatic API**: Full Rust API for attribute management
- **🔧 Enhanced GRL Parser**: Support for flexible rule attribute syntax in any position
- **🧪 Comprehensive Testing**: 27/27 unit tests including new agenda management tests
- **📚 Complete Demo**: Full demonstration of all 4 attribute features
- **⚡ Performance Optimized**: Efficient agenda focus stack and activation group management

### v0.5.0 (October 2025) - AI Integration 🤖
- **🤖 AI-Powered Rules**: Built-in support for AI/ML model integration
  - Sentiment analysis functions for customer service automation
  - ML-powered fraud detection with real-time risk scoring
  - Predictive analytics for customer tier assignment
  - LLM reasoning for complex business decision support
  - Real-time ML scoring for dynamic pricing and recommendations
- **🧠 AI Function Registry**: Easy registration and management of AI model functions
- **🚀 Production AI Examples**: Complete examples with simulated AI APIs
- **📊 AI Insights**: Track AI model performance and decision outcomes
- **🌐 AI-Enhanced REST API**: HTTP endpoints for AI-powered rule execution

### v0.4.1 (October 2025) - Enhanced Parser & Publishing
- **🔧 Enhanced GRL Parser**: Improved parsing with complex nested conditions
  - Support for parentheses grouping: `(age >= 18) && (status == "active")`
  - Better handling of compound boolean expressions
  - Improved error messages and validation
- **📦 Published to Crates.io**: Available as `rust-rule-engine = "0.4.1"`
- **📚 Comprehensive Examples**: Added 40+ examples covering all features
- **📖 Complete Documentation**: Full API documentation and usage guides

### v0.3.1 (October 2025) - REST API with Monitoring
- **🌐 Production REST API**: Complete web API with advanced analytics integration
  - Comprehensive endpoints for rule execution and monitoring
  - Real-time analytics dashboard with performance insights
  - Health monitoring and system status endpoints
  - CORS support and proper error handling
  - Sample requests and complete API documentation
  - Production-ready demo script for testing

### v0.3.0 (October 2025) - AST-Based Dependency Analysis & Advanced Analytics

## 🚀 Quick Start

Add to your `Cargo.toml`:

```toml
[dependencies]
rust-rule-engine = "0.8.0"
chrono = "0.4"  # For date-based rule attributes

# For streaming features (optional)
rust-rule-engine = { version = "0.8.0", features = ["streaming"] }
```

### 📄 File-Based Rules

Create a rule file `rules/example.grl`:

```grl
rule "AgeCheck" salience 10 {
    when
        User.Age >= 18 && User.Country == "US"
    then
        User.setIsAdult(true);
        User.setCategory("Adult");
        log("User qualified as adult");
}

rule "VIPUpgrade" salience 20 {
    when
        User.IsAdult == true && User.SpendingTotal > 1000.0
    then
        User.setIsVIP(true);
        log("User upgraded to VIP status");
}
```

```rust
use rust_rule_engine::{RuleEngineBuilder, Value, Facts};
use std::collections::HashMap;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create engine with rule file
    let mut engine = RuleEngineBuilder::new()
        .with_rule_file("rules/example.grl")?
        .build();

    // Register custom functions
    engine.register_function("User.setIsAdult", |args, _| {
        println!("Setting adult status: {:?}", args[0]);
        Ok(Value::Boolean(true))
    });

    engine.register_function("User.setCategory", |args, _| {
        println!("Setting category: {:?}", args[0]);
        Ok(Value::String(args[0].to_string()))
    });

    // Create facts
    let facts = Facts::new();
    let mut user = HashMap::new();
    user.insert("Age".to_string(), Value::Integer(25));
    user.insert("Country".to_string(), Value::String("US".to_string()));
    user.insert("SpendingTotal".to_string(), Value::Number(1500.0));

    facts.add_value("User", Value::Object(user))?;

    // Execute rules
    let result = engine.execute(&facts)?;
    println!("Rules fired: {}", result.rules_fired);

    Ok(())
}
```

### 📝 Inline String Rules

Define rules directly in your code:

```rust
use rust_rule_engine::{RuleEngineBuilder, Value, Facts};
use std::collections::HashMap;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let grl_rules = r#"
        rule "HighValueCustomer" salience 20 {
            when
                Customer.TotalSpent > 1000.0
            then
                sendWelcomeEmail(Customer.Email, "GOLD");
                log("Customer upgraded to GOLD tier");
        }

        rule "LoyaltyBonus" salience 15 {
            when
                Customer.OrderCount >= 10
            then
                applyLoyaltyBonus(Customer.Id, 50.0);
                log("Loyalty bonus applied");
        }
    "#;

    // Create engine with inline rules
    let mut engine = RuleEngineBuilder::new()
        .with_inline_grl(grl_rules)?
        .build();

    // Register custom functions
    engine.register_function("sendWelcomeEmail", |args, _| {
        println!("📧 Welcome email sent to {:?} for {:?} tier", args[0], args[1]);
        Ok(Value::Boolean(true))
    });

    engine.register_function("applyLoyaltyBonus", |args, _| {
        println!("💰 Loyalty bonus of {:?} applied to customer {:?}", args[1], args[0]);
        Ok(Value::Number(args[1].as_number().unwrap_or(0.0)))
    });

    // Create facts
    let facts = Facts::new();
    let mut customer = HashMap::new();
    customer.insert("TotalSpent".to_string(), Value::Number(1250.0));
    customer.insert("OrderCount".to_string(), Value::Integer(12));
    customer.insert("Email".to_string(), Value::String("john@example.com".to_string()));
    customer.insert("Id".to_string(), Value::String("CUST001".to_string()));

    facts.add_value("Customer", Value::Object(customer))?;

    // Execute rules
    let result = engine.execute(&facts)?;
    println!("Rules fired: {}", result.rules_fired);

    Ok(())
}
```

### 🎯 Rule Attributes Quick Example

Experience the power of Rule Attributes v0.6.0 with workflow control:

```rust
use rust_rule_engine::{RuleEngineBuilder, Value, Facts};
use std::collections::HashMap;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let attribute_rules = r#"
        rule "ValidateAge" agenda-group "validation" salience 10 {
            when
                User.age >= 18
            then
                User.status = "valid";
                log("Age validation passed");
        }

        rule "ProcessPayment" agenda-group "processing" salience 10 {
            when
                User.status == "valid"
            then
                Order.status = "processed";
                log("Payment processed");
        }

        rule "PremiumDiscount" activation-group "discount" salience 10 {
            when Customer.tier == "premium"
            then Order.discount = 0.20;
        }

        rule "GoldDiscount" activation-group "discount" salience 8 {
            when Customer.tier == "gold"
            then Order.discount = 0.15;
        }

        rule "WelcomeEmail" lock-on-active salience 15 {
            when Customer.isNew == true
            then sendWelcomeEmail(Customer.email);
        }
    "#;

    // Create engine with attribute rules
    let mut engine = RuleEngineBuilder::new()
        .with_inline_grl(attribute_rules)?
        .build();

    // Create facts
    let facts = Facts::new();
    
    // Add user data
    let mut user = HashMap::new();
    user.insert("age".to_string(), Value::Integer(25));
    user.insert("status".to_string(), Value::String("pending".to_string()));
    facts.add_value("User", Value::Object(user))?;

    let mut customer = HashMap::new();
    customer.insert("tier".to_string(), Value::String("premium".to_string()));
    customer.insert("isNew".to_string(), Value::Boolean(true));
    customer.insert("email".to_string(), Value::String("user@example.com".to_string()));
    facts.add_value("Customer", Value::Object(customer))?;

    let mut order = HashMap::new();
    order.insert("status".to_string(), Value::String("pending".to_string()));
    order.insert("discount".to_string(), Value::Number(0.0));
    facts.add_value("Order", Value::Object(order))?;

    // 🔍 Phase 1: Validation workflow
    engine.set_agenda_focus("validation");
    let result1 = engine.execute(&facts)?;
    println!("✅ Validation phase: {} rules fired", result1.rules_fired);

    // ⚙️ Phase 2: Processing workflow  
    engine.set_agenda_focus("processing");
    let result2 = engine.execute(&facts)?;
    println!("🔄 Processing phase: {} rules fired", result2.rules_fired);

    // 🎯 Phase 3: Discount (only ONE rule fires due to activation-group)
    engine.set_agenda_focus("MAIN"); // Default group
    let result3 = engine.execute(&facts)?;
    println!("💰 Discount phase: {} rules fired (mutually exclusive)", result3.rules_fired);

    Ok(())
}
```

## 🎨 Visual Rule Builder (NEW!)

**Create rules visually with our drag-and-drop interface!**

🌐 **[Visual Rule Builder](https://visual-rule-builder.amalthea.cloud/)** - Build GRL rules without coding!

### ✨ Features
- **🎯 Drag & Drop Interface**: Intuitive visual rule creation
- **📝 Real-time GRL Generation**: See your rules as GRL code instantly
- **🔍 Syntax Validation**: Automatic validation and error checking
- **📋 Template Library**: Pre-built rule templates for common scenarios
- **💾 Export & Import**: Save and load your rule configurations
- **🚀 One-Click Integration**: Copy-paste generated GRL directly into your Rust projects

### 🎮 Quick Demo

1. **Visit**: [https://visual-rule-builder.amalthea.cloud/](https://visual-rule-builder.amalthea.cloud/)
2. **Build**: Drag conditions and actions to create your business logic
3. **Generate**: Get clean, optimized GRL code automatically
4. **Integrate**: Copy the GRL into your Rust Rule Engine project

### 📚 Perfect For
- **🎓 Learning**: Understand rule structure and syntax visually
- **⚡ Rapid Prototyping**: Quickly build and test rule logic
- **👥 Business Users**: Create rules without programming knowledge
- **🔧 Complex Rules**: Visualize intricate business logic flows

### 💡 Example Workflow

```grl
// Generated from Visual Builder
rule "CustomerUpgrade" salience 20 {
    when
        Customer.totalSpent > 1000.0 && 
        Customer.loyaltyYears >= 2 &&
        !exists(Customer.tier == "VIP")
    then
        Customer.tier = "VIP";
        sendWelcomePackage(Customer.email);
        log("Customer upgraded to VIP status");
}
```

**Try it now**: Build this rule visually in under 2 minutes! 🚀

---

## 🤖 Complete AI Integration Example

Here's a complete example showing how to build an AI-powered business rule system:

```rust
use rust_rule_engine::{RuleEngineBuilder, Value, Facts};
use std::collections::HashMap;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let ai_rules = r#"
        rule "AI Customer Service" salience 100 {
            when
                CustomerMessage.type == "complaint"
            then
                analyzeSentiment(CustomerMessage.text);
                set(Ticket.priority, "high");
                logMessage("🤖 AI analyzing customer sentiment");
        }

        rule "AI Fraud Detection" salience 90 {
            when
                Transaction.amount > 1000
            then
                detectFraud(Transaction.amount, Transaction.userId);
                set(Transaction.status, "under_review");
                sendNotification("🛡️ Checking for potential fraud", "security@company.com");
        }

        rule "AI Tier Prediction" salience 80 {
            when
                Customer.tier == "pending"
            then
                predictTier(Customer.id);
                set(Customer.tierAssignedBy, "AI");
                logMessage("🏆 AI predicting customer tier");
        }

        rule "LLM Decision Support" salience 70 {
            when
                Customer.needsReview == true
            then
                askLLM("Should we approve this customer for premium tier?", Customer.id);
                set(Customer.reviewedBy, "AI-LLM");
                logMessage("🧠 LLM analyzing customer for approval");
        }

        rule "ML Dynamic Pricing" salience 60 {
            when
                Product.category == "dynamic" && Customer.tier != "unknown"
            then
                calculateMLPrice(Product.basePrice, Customer.tier, Product.demand);
                set(Product.priceSource, "ML");
                logMessage("📊 ML calculating dynamic price");
        }
    "#;

    let mut engine = RuleEngineBuilder::new()
        .with_inline_grl(ai_rules)?
        .with_max_cycles(5)
        .build();

    // Register AI functions (in production, these would call real AI APIs)
    engine.register_function("analyzeSentiment", |args, facts| {
        let text = args[0].as_string().unwrap_or("".to_string());
        
        // Simulate sentiment analysis (OpenAI, Anthropic, HuggingFace, etc.)
        let sentiment = if text.contains("terrible") || text.contains("awful") {
            "negative"
        } else if text.contains("love") || text.contains("great") {
            "positive"
        } else {
            "neutral"
        };
        
        // Store result in facts for other rules
        facts.set_value("Analysis.sentiment", Value::String(sentiment.to_string()))?;
        
        println!("🤖 Sentiment Analysis: '{}' → {}", text, sentiment);
        Ok(Value::String(sentiment.to_string()))
    });

    engine.register_function("detectFraud", |args, facts| {
        let amount = args[0].as_number().unwrap_or(0.0);
        let user_id = args[1].as_string().unwrap_or("unknown".to_string());
        
        // Simulate ML fraud detection model
        let risk_score = if amount > 5000.0 { 0.95 } else if amount > 2000.0 { 0.75 } else { 0.2 };
        let is_fraud = risk_score > 0.8;
        
        facts.set_value("FraudCheck.riskScore", Value::Number(risk_score))?;
        facts.set_value("FraudCheck.isFraud", Value::Boolean(is_fraud))?;
        
        println!("🛡️ Fraud Detection: Amount {} for user {} → Risk: {:.2}, Fraud: {}", 
                amount, user_id, risk_score, is_fraud);
        
        Ok(Value::Boolean(is_fraud))
    });

    engine.register_function("predictTier", |args, facts| {
        let customer_id = args[0].as_string().unwrap_or("unknown".to_string());
        
        // Simulate customer tier prediction model
        let predicted_tiers = ["bronze", "silver", "gold", "platinum"];
        let tier = predicted_tiers[customer_id.len() % predicted_tiers.len()];
        
        facts.set_value("TierPrediction.tier", Value::String(tier.to_string()))?;
        facts.set_value("TierPrediction.confidence", Value::Number(0.87))?;
        
        println!("🏆 Tier Prediction: Customer {} → {} tier (87% confidence)", customer_id, tier);
        Ok(Value::String(tier.to_string()))
    });

    engine.register_function("askLLM", |args, facts| {
        let question = args[0].as_string().unwrap_or("".to_string());
        let customer_id = args[1].as_string().unwrap_or("unknown".to_string());
        
        // Simulate LLM reasoning (GPT-4, Claude, etc.)
        let decision = if customer_id.contains("VIP") { "approve" } else { "review_further" };
        let reasoning = format!("Based on customer profile analysis, recommendation: {}", decision);
        
        facts.set_value("LLMDecision.result", Value::String(decision.to_string()))?;
        facts.set_value("LLMDecision.reasoning", Value::String(reasoning.clone()))?;
        
        println!("🧠 LLM Analysis: {} → {}", question, reasoning);
        Ok(Value::String(decision.to_string()))
    });

    engine.register_function("calculateMLPrice", |args, facts| {
        let base_price = args[0].as_number().unwrap_or(100.0);
        let tier = args[1].as_string().unwrap_or("bronze".to_string());
        let demand = args[2].as_number().unwrap_or(1.0);
        
        // Simulate ML pricing model
        let tier_multiplier = match tier.as_str() {
            "platinum" => 0.8,
            "gold" => 0.9,
            "silver" => 0.95,
            _ => 1.0,
        };
        
        let dynamic_price = base_price * tier_multiplier * demand;
        
        facts.set_value("Pricing.dynamicPrice", Value::Number(dynamic_price))?;
        facts.set_value("Pricing.discount", Value::Number((1.0 - tier_multiplier) * 100.0))?;
        
        println!("📊 ML Pricing: Base ${:.2} × {} tier × {:.1}x demand → ${:.2}", 
                base_price, tier, demand, dynamic_price);
        
        Ok(Value::Number(dynamic_price))
    });

    // Helper functions
    engine.register_function("set", |args, facts| {
        if args.len() >= 2 {
            let key = args[0].as_string().unwrap_or("unknown".to_string());
            facts.set_value(&key, args[1].clone())?;
        }
        Ok(Value::Boolean(true))
    });

    engine.register_function("logMessage", |args, _| {
        println!("📝 {}", args[0]);
        Ok(Value::Boolean(true))
    });

    engine.register_function("sendNotification", |args, _| {
        println!("📧 Notification: {} → {}", args[0], args[1]);
        Ok(Value::Boolean(true))
    });

    // Set up test facts
    let facts = Facts::new();
    
    // Customer service scenario
    let mut customer_message = HashMap::new();
    customer_message.insert("type".to_string(), Value::String("complaint".to_string()));
    customer_message.insert("text".to_string(), Value::String("This service is terrible!".to_string()));
    facts.add_value("CustomerMessage", Value::Object(customer_message))?;

    // Transaction for fraud detection
    let mut transaction = HashMap::new();
    transaction.insert("amount".to_string(), Value::Number(2500.0));
    transaction.insert("userId".to_string(), Value::String("user123".to_string()));
    facts.add_value("Transaction", Value::Object(transaction))?;

    // Customer for tier prediction
    let mut customer = HashMap::new();
    customer.insert("id".to_string(), Value::String("VIP_customer_456".to_string()));
    customer.insert("tier".to_string(), Value::String("pending".to_string()));
    customer.insert("needsReview".to_string(), Value::Boolean(true));
    facts.add_value("Customer", Value::Object(customer))?;

    // Product for dynamic pricing
    let mut product = HashMap::new();
    product.insert("category".to_string(), Value::String("dynamic".to_string()));
    product.insert("basePrice".to_string(), Value::Number(150.0));
    product.insert("demand".to_string(), Value::Number(1.3));
    facts.add_value("Product", Value::Object(product))?;

    let mut ticket = HashMap::new();
    facts.add_value("Ticket", Value::Object(ticket))?;

    // Execute AI-powered rules
    println!("\n🚀 Executing AI-Powered Rule Engine...\n");
    let result = engine.execute(&facts)?;
    
    println!("\n📊 Execution Results:");
    println!("   Rules fired: {}", result.rules_fired);
    println!("   Cycles: {}", result.cycles);
    println!("   Duration: {:?}", result.duration);
    
    Ok(())
}
```

### 🔍 Dependency Analysis Example

```rust
use rust_rule_engine::dependency::DependencyAnalyzer;

fn analyze_rule_dependencies() -> Result<(), Box<dyn std::error::Error>> {
    let grl_content = r#"
        rule "VIPUpgrade" {
            when Customer.TotalSpent > 1000.0 && Customer.IsVIP == false
            then 
                Customer.setIsVIP(true);
                Customer.setTier("GOLD");
        }
        
        rule "VIPBenefits" {
            when Customer.IsVIP == true
            then
                Order.setDiscountRate(0.15);
                log("VIP discount applied");
        }
    "#;

    let analyzer = DependencyAnalyzer::new();
    let analysis = analyzer.analyze_grl_rules(grl_content)?;
    
    // Show detected dependencies
    for rule in &analysis.rules {
        println!("📋 Rule '{}' reads: {:?}", rule.name, rule.reads);
        println!("✏️  Rule '{}' writes: {:?}", rule.name, rule.writes);
    }
    
    // Check for conflicts
    let conflicts = analysis.find_conflicts();
    if conflicts.is_empty() {
        println!("✅ No conflicts detected - rules can execute safely in parallel");
    } else {
        println!("⚠️  {} conflicts detected", conflicts.len());
    }
    
    Ok(())
}
```

## 🎯 GRL Rule Language Features

### Supported Syntax

```grl
// Basic rule
rule "RuleName" salience 10 {
    when
        Object.Property > 100 &&
        Object.Status == "ACTIVE"
    then
        Object.setCategory("HIGH_VALUE");
        processTransaction(Object.Id, Object.Amount);
        log("Rule executed successfully");
}

// Rule with no-loop protection (prevents infinite self-activation)
rule "ScoreUpdater" no-loop salience 15 {
    when
        Player.score < 100
    then
        set(Player.score, Player.score + 10);
        log("Score updated with no-loop protection");
}
```

### Operators

- **Comparison**: `>`, `>=`, `<`, `<=`, `==`, `!=`
- **Logical**: `&&`, `||` 
- **Value Types**: Numbers, Strings (quoted), Booleans (`true`/`false`)

### Actions

- **Method Calls**: `Object.method(args)`
- **Function Calls**: `functionName(args)`
- **Logging**: `log("message")`

## 📚 Examples

### 🛒 E-commerce Rules

```grl
rule "VIPCustomer" salience 20 {
    when
        Customer.TotalSpent > 5000.0 && Customer.YearsActive >= 2
    then
        Customer.setTier("VIP");
        sendWelcomePackage(Customer.Email, "VIP");
        applyDiscount(Customer.Id, 15.0);
        log("Customer upgraded to VIP");
}

rule "LoyaltyReward" salience 15 {
    when
        Customer.OrderCount >= 50
    then
        addLoyaltyPoints(Customer.Id, 500);
        log("Loyalty reward applied");
}
```

### 🚗 Vehicle Monitoring

```grl
rule "SpeedLimit" salience 25 {
    when
        Vehicle.Speed > Vehicle.SpeedLimit
    then
        triggerAlert(Vehicle.Id, "SPEED_VIOLATION");
        logViolation(Vehicle.Driver, Vehicle.Speed);
        Vehicle.setStatus("FLAGGED");
}

rule "MaintenanceDue" salience 10 {
    when
        Vehicle.Mileage > Vehicle.NextMaintenance
    then
        scheduleService(Vehicle.Id, Vehicle.Mileage);
        notifyDriver(Vehicle.Driver, "Maintenance due");
}
```

### 🧩 Pattern Matching Examples

```grl
rule "VIPServiceActivation" "Activate VIP service when VIP customer exists" salience 20 {
    when
        exists(Customer.tier == "VIP")
    then
        System.vipServiceActive = true;
        log("VIP service activated - VIP customer detected");
}

rule "MarketingCampaign" "Send marketing when no pending orders" salience 15 {
    when
        !exists(Order.status == "pending")
    then
        Marketing.emailSent = true;
        sendMarketingEmail();
        log("Marketing campaign sent - no pending orders");
}

rule "ShippingEnable" "Enable shipping when all orders processed" salience 10 {
    when
        forall(Order.status == "processed")
    then
        Shipping.enabled = true;
        enableShippingService();
        log("Shipping enabled - all orders processed");
}

rule "ComplexBusinessLogic" "Complex pattern combination" salience 25 {
    when
        exists(Customer.tier == "VIP") && 
        !exists(Alert.priority == "high") &&
        forall(Order.status == "processed")
    then
        System.premiumModeEnabled = true;
        activatePremiumFeatures();
        log("Premium mode activated - all conditions met");
}
```

**Run Pattern Matching Examples:**

```bash
# Programmatic pattern matching demo
cargo run --example pattern_matching_demo

# GRL file-based pattern matching
cargo run --example simple_pattern_matching_grl

# Complex patterns from GRL files  
cargo run --example pattern_matching_from_grl
```

## 🌐 REST API with Monitoring

The engine provides a production-ready REST API with comprehensive analytics monitoring.

### Quick Start

```bash
# Run the REST API server with full analytics monitoring
cargo run --example rest_api_monitoring

# Or use the demo script for testing
./demo_rest_api.sh
```

### Available Endpoints

**Rule Execution:**
- `POST /api/v1/rules/execute` - Execute rules with provided facts
- `POST /api/v1/rules/batch` - Execute rules in batch mode

**Analytics & Monitoring:**
- `GET /api/v1/analytics/dashboard` - Comprehensive analytics dashboard
- `GET /api/v1/analytics/stats` - Overall performance statistics  
- `GET /api/v1/analytics/recent` - Recent execution activity
- `GET /api/v1/analytics/recommendations` - Performance optimization recommendations
- `GET /api/v1/analytics/rules/{rule_name}` - Rule-specific analytics

**System:**
- `GET /` - API documentation
- `GET /api/v1/health` - Health check
- `GET /api/v1/status` - System status

### Example Requests

**Execute Rules:**
```bash
curl -X POST "http://localhost:3000/api/v1/rules/execute" \
  -H "Content-Type: application/json" \
  -d '{
    "facts": {
      "Customer": {
        "Age": 35,
        "IsNew": false,
        "OrderCount": 75,
        "TotalSpent": 15000.0,
        "YearsActive": 3,
        "Email": "customer@example.com"
      },
      "Order": {
        "Amount": 750.0,
        "CustomerEmail": "customer@example.com"
      }
    }
  }'
```

**Analytics Dashboard:**
```bash
curl "http://localhost:3000/api/v1/analytics/dashboard"
```

**Sample Response:**
```json
{
  "overall_stats": {
    "total_executions": 1250,
    "avg_execution_time_ms": 2.3,
    "success_rate": 99.8,
    "rules_per_second": 435.2,
    "uptime_hours": 24.5
  },
  "top_performing_rules": [
    {
      "name": "VIPCustomerRule",
      "execution_count": 340,
      "avg_duration_ms": 1.8,
      "success_rate": 100.0
    }
  ],
  "recommendations": [
    "Consider caching customer data to improve performance",
    "Rule 'ComplexValidation' shows high execution time"
  ]
}
```

### Production Configuration

The REST API includes:
- **Real-time Analytics**: Live performance monitoring
- **Health Checks**: Comprehensive system health monitoring
- **CORS Support**: Cross-origin resource sharing
- **Error Handling**: Proper HTTP status codes and error messages
- **Sampling**: Configurable analytics sampling for high-volume scenarios
- **Memory Management**: Automatic cleanup and retention policies

## ⚡ Performance & Architecture

### Benchmarks

Performance benchmarks on a typical development machine:

```text
Simple Rule Execution:
• Single condition rule:     ~4.5 µs per execution
• With custom function call: ~4.8 µs per execution

Complex Rule Execution:
• Multi-condition rules:     ~2.7 µs per execution  
• 3 rules with conditions:   ~2.8 µs per execution

Rule Parsing:
• Simple GRL rule:          ~1.1 µs per parse
• Medium complexity rule:   ~1.4 µs per parse  
• Complex multi-line rule:  ~2.0 µs per parse

Facts Operations:
• Create complex facts:     ~1.8 µs
• Get nested fact:          ~79 ns
• Set nested fact:          ~81 ns

Memory Usage:
• Base engine overhead:     ~10KB
• Per rule storage:         ~1-2KB  
• Per fact storage:         ~100-500 bytes
```

*Run benchmarks: `cargo bench`*

**Key Performance Insights:**
- **Ultra-fast execution**: Rules execute in microseconds
- **Efficient parsing**: GRL rules parse in under 2µs  
- **Optimized facts**: Nanosecond-level fact operations
- **Low memory footprint**: Minimal overhead per rule
- **Scales linearly**: Performance consistent across rule counts

### 🏆 **Performance Comparison**

Benchmark comparison with other rule engines:

```text
Language/Engine        Rule Execution    Memory Usage    Startup Time
─────────────────────────────────────────────────────────────────────
Rust (this engine)     2-5µs            1-2KB/rule     ~1ms
.NET Rules Engine       15-50µs          3-8KB/rule     ~50-100ms
Go Rules Framework      10-30µs          2-5KB/rule     ~10-20ms
Java Drools            50-200µs          5-15KB/rule    ~200-500ms
Python rule-engine     500-2000µs        8-20KB/rule    ~100-300ms
```

**Rust Advantages:**
- **10x faster** than .NET rule engines
- **5x faster** than Go-based rule frameworks  
- **50x faster** than Java Drools
- **400x faster** than Python implementations
- **Zero GC pauses** (unlike .NET/Java/Go)
- **Minimal memory footprint** 
- **Instant startup** time

**Why Rust Wins:**
- No garbage collection overhead
- Zero-cost abstractions
- Direct memory management
- LLVM optimizations
- No runtime reflection costs

### Key Design Decisions

- **GRL-Only**: Removed JSON support for cleaner, focused API
- **Dual Sources**: Support both file-based and inline rule definitions
- **Custom Functions**: Extensible function registry for business logic
- **Builder Pattern**: Fluent API for easy engine configuration
- **Type Safety**: Leverages Rust's type system for runtime safety
- **Zero-Copy**: Efficient string and memory management

## 🔍 Advanced Dependency Analysis (v0.3.0+)

The rule engine features sophisticated **AST-based dependency analysis** that automatically detects field dependencies and potential conflicts between rules.

### Smart Field Detection

```rust
use rust_rule_engine::{RuleEngineBuilder, dependency::DependencyAnalyzer};

// Automatic field dependency detection
let rules = r#"
    rule "DiscountRule" {
        when Customer.VIP == true && Order.Amount > 100.0
        then 
            Order.setDiscount(0.2);
            Customer.setPoints(Customer.Points + 50);
    }
    
    rule "ShippingRule" {
        when Order.Amount > 50.0
        then
            Order.setFreeShipping(true);
            log("Free shipping applied");
    }
"#;

let analyzer = DependencyAnalyzer::new();
let analysis = analyzer.analyze_grl_rules(rules)?;

// Automatically detected dependencies:
// DiscountRule reads: [Customer.VIP, Order.Amount, Customer.Points]
// DiscountRule writes: [Order.Discount, Customer.Points]
// ShippingRule reads: [Order.Amount]  
// ShippingRule writes: [Order.FreeShipping]
```

### Conflict Detection

```rust
// Detect read-write conflicts between rules
let conflicts = analysis.find_conflicts();
for conflict in conflicts {
    println!("⚠️  Conflict: {} reads {} while {} writes {}",
        conflict.reader_rule, conflict.field,
        conflict.writer_rule, conflict.field
    );
}

// Smart execution ordering based on dependencies
let execution_order = analysis.suggest_execution_order();
```

### Advanced Features

- **🎯 AST-Based Analysis**: Proper parsing instead of regex pattern matching
- **🔄 Recursive Conditions**: Handles nested condition groups (AND/OR/NOT)
- **🧠 Function Side-Effects**: Infers field modifications from function calls
- **⚡ Zero False Positives**: Accurate dependency detection
- **📊 Conflict Resolution**: Automatic rule ordering suggestions
- **🚀 Parallel Safety**: Enables safe concurrent rule execution

## 📋 API Reference

### Core Types

```rust
// Main engine builder
RuleEngineBuilder::new()
    .with_rule_file("path/to/rules.grl")?
    .with_inline_grl("rule content")?
    .with_config(config)
    .build()

// Value types
Value::Integer(42)
Value::Number(3.14)
Value::String("text".to_string())
Value::Boolean(true)
Value::Object(HashMap<String, Value>)

// Facts management
let facts = Facts::new();
facts.add_value("Object", value)?;
facts.get("Object")?;

// Execution results
result.rules_fired       // Number of rules that executed
result.cycle_count       // Number of execution cycles
result.execution_time    // Duration of execution
```

### Function Registration

```rust
engine.register_function("functionName", |args, facts| {
    // args: Vec<Value> - function arguments
    // facts: &Facts - current facts state
    // Return: Result<Value, RuleEngineError>
    
    let param1 = &args[0];
    let param2 = args[1].as_number().unwrap_or(0.0);
    
    // Your custom business logic here
    println!("Function called with: {:?}", args);
    
    Ok(Value::String("Success".to_string()))
});
```

## ⚡ Parallel Rule Execution

The engine supports parallel execution for improved performance with large rule sets:

```rust
use rust_rule_engine::engine::parallel::{ParallelEngine, ParallelConfig};

// Create parallel engine with custom configuration
let config = ParallelConfig {
    enabled: true,
    max_threads: 4,
};

let mut engine = ParallelEngine::new(config);

// Add rules and facts
engine.add_rule(rule);
engine.insert_fact("User", user_data);

// Execute rules in parallel
let result = engine.execute_parallel(10).await;
println!("Rules fired: {}", result.total_rules_fired);
println!("Execution time: {:?}", result.execution_time);
println!("Parallel speedup: {:.2}x", result.parallel_speedup);
```

### Parallel Execution Examples

```bash
# Simple parallel demo
cargo run --example simple_parallel_demo

# Performance comparison
cargo run --example financial_stress_test
```

## 🌐 Distributed & Cloud Features

Scale your rule engine across multiple nodes for high-performance distributed processing:

### Architecture Overview

```
                    ┌─────────────────────┐
                    │   Load Balancer     │
                    │   (Route Requests)  │
                    └──────────┬──────────┘
                               │
        ┌──────────────────────┼──────────────────────┐
        │                      │                      │
   ┌─────────┐            ┌─────────┐            ┌─────────┐
   │ Node 1  │            │ Node 2  │            │ Node 3  │
   │Validation│           │ Pricing │            │ Loyalty │
   │  Rules  │            │  Rules  │            │  Rules  │
   └─────────┘            └─────────┘            └─────────┘
        │                      │                      │
        └──────────────────────┼──────────────────────┘
                               │
                    ┌──────────▼──────────┐
                    │   Shared Data       │
                    │ (Redis/PostgreSQL)  │
                    └─────────────────────┘
```

### Performance Benefits

- **⚡ 3x Performance**: Parallel processing across specialized nodes
- **🛡️ Fault Tolerance**: If one node fails, others continue operation
- **📈 Horizontal Scaling**: Add nodes to increase capacity
- **🌍 Geographic Distribution**: Deploy closer to users for reduced latency

### Quick Demo

```bash
# Compare single vs distributed processing
cargo run --example distributed_concept_demo
```

**Results:**
```
Single Node:    1.4 seconds (sequential)
Distributed:    0.47 seconds (parallel)
→ 3x Performance Improvement!
```

### Implementation Guide

See our comprehensive guides:
- 📚 [Distributed Architecture Guide](docs/distributed_features_guide.md)
- 🚀 [Real-world Examples](docs/distributed_explained.md)
- 🔧 [Implementation Roadmap](docs/distributed_architecture.md)

### Cloud Deployment

Deploy on major cloud platforms:

**Kubernetes:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rule-engine-workers
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rule-engine
```

**Docker:**
```dockerfile
FROM rust:alpine
COPY target/release/rust-rule-engine /app/
EXPOSE 8080
CMD ["/app/rust-rule-engine"]
```

### When to Use Distributed Architecture

✅ **Recommended for:**
- High traffic (>10,000 requests/day)
- Complex rule sets (>500 rules)
- High availability requirements
- Geographic distribution needs

❌ **Not needed for:**
- Simple applications (<100 rules)
- Low traffic scenarios
- Development/prototyping
- Limited infrastructure budget

## 🧪 All Examples

### Core Features
```bash
# Basic rule execution
cargo run --example grule_demo

# E-commerce rules
cargo run --example ecommerce

# Custom functions
cargo run --example custom_functions_demo

# Method calls
cargo run --example method_calls_demo
```

### Workflow Engine (v0.8.0)
```bash
# Basic workflow demo with order processing
cargo run --example workflow_engine_demo

# Advanced workflow with scheduled tasks
cargo run --example advanced_workflow_demo
```

### Action Handlers (v0.7.1)
```bash
# Action handlers with programmatic API
cargo run --example action_handlers_demo

# Action handlers from GRL files
cargo run --example action_handlers_grl_demo
```

### Performance & Scaling
```bash
# Parallel processing comparison
cargo run --example simple_parallel_demo

# Financial stress testing
cargo run --example financial_stress_test

# Distributed architecture demo
cargo run --example distributed_concept_demo
```

### Advanced Features
```bash
# Pattern matching (v0.7.0)
cargo run --example pattern_matching_demo
cargo run --example simple_pattern_matching_grl
cargo run --example pattern_matching_from_grl

# REST API with analytics
cargo run --example rest_api_monitoring

# Analytics and monitoring
cargo run --example analytics_demo

# Rule file processing
cargo run --example rule_file_functions_demo

# Advanced dependency analysis
cargo run --example advanced_dependency_demo
```

### Production Examples
```bash
# Fraud detection system
cargo run --example fraud_detection

# Complete speedup demo
cargo run --example complete_speedup_demo

# Debug conditions
cargo run --example debug_conditions
```

## 🌊 Streaming Rule Engine (v0.2.0+)

For real-time event processing, enable the `streaming` feature:
```

## 🌊 Streaming Rule Engine (v0.2.0+)

For real-time rule processing with streaming data:

```rust
use rust_rule_engine::streaming::*;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut engine = StreamRuleEngine::new();
    
    // Add streaming rules
    engine.add_rule(r#"
    rule "HighVolumeAlert" {
        when
            WindowEventCount > 100 && volumeSum > 1000000
        then
            AlertService.trigger("High volume detected");
    }
    "#).await?;
    
    // Register action handlers
    engine.register_action_handler("AlertService", |action| {
        println!("🚨 Alert: {:?}", action.parameters);
    }).await;
    
    // Start processing
    engine.start().await?;
    
    // Send events
    let event = StreamEvent::new("TradeEvent", data, "exchange");
    engine.send_event(event).await?;
    
    Ok(())
}
```

**Streaming Features:**
- **⏰ Time Windows**: Sliding/tumbling window aggregations
- **📊 Real-time Analytics**: Count, sum, average, min/max over windows  
- **🎯 Pattern Matching**: Event correlation and filtering
- **⚡ High Throughput**: Async processing with backpressure handling
- **🚨 Action Handlers**: Custom callbacks for rule consequences

### Real-World Integration Examples

#### 🔌 **Kafka Consumer**
```rust
use rdkafka::consumer::{Consumer, StreamConsumer};

async fn consume_from_kafka(engine: Arc<StreamRuleEngine>) {
    let consumer: StreamConsumer = ClientConfig::new()
        .set("group.id", "trading-group")
        .set("bootstrap.servers", "localhost:9092")
        .create().unwrap();
    
    consumer.subscribe(&["trading-events"]).unwrap();
    
    loop {
        match consumer.recv().await {
            Ok(message) => {
                let event = parse_kafka_message(message);
                engine.send_event(event).await?;
            }
            Err(e) => eprintln!("Kafka error: {}", e),
        }
    }
}
```

#### 🌐 **WebSocket Stream**
```rust
use tokio_tungstenite::{connect_async, tungstenite::Message};

async fn consume_from_websocket(engine: Arc<StreamRuleEngine>) {
    let (ws_stream, _) = connect_async("wss://api.exchange.com/stream").await?;
    let (_, mut read) = ws_stream.split();
    
    while let Some(msg) = read.next().await {
        match msg? {
            Message::Text(text) => {
                let trade_data: TradeData = serde_json::from_str(&text)?;
                let event = convert_to_stream_event(trade_data);
                engine.send_event(event).await?;
            }
            _ => {}
        }
    }
}
```

#### 🔄 **HTTP API Polling**
```rust
async fn poll_trading_api(engine: Arc<StreamRuleEngine>) {
    let client = reqwest::Client::new();
    let mut interval = interval(Duration::from_secs(1));
    
    loop {
        interval.tick().await;
        
        match client.get("https://api.exchange.com/trades").send().await {
            Ok(response) => {
                let trades: Vec<Trade> = response.json().await?;
                
                for trade in trades {
                    let event = StreamEvent::new(
                        "TradeEvent",
                        trade.to_hashmap(),
                        "exchange_api"
                    );
                    engine.send_event(event).await?;
                }
            }
            Err(e) => eprintln!("API error: {}", e),
        }
    }
}
```

#### 🗄️ **Database Change Streams**
```rust
async fn watch_database_changes(engine: Arc<StreamRuleEngine>) {
    let mut change_stream = db.collection("trades")
        .watch(None, None).await?;
    
    while let Some(change) = change_stream.next().await {
        let change_doc = change?;
        
        if let Some(full_document) = change_doc.full_document {
            let event = StreamEvent::new(
                "DatabaseChange",
                document_to_hashmap(full_document),
                "mongodb"
            );
            engine.send_event(event).await?;
        }
    }
}
```

#### 📂 **File Watching**
```rust
use notify::{Watcher, RecursiveMode, watcher};

async fn watch_log_files(engine: Arc<StreamRuleEngine>) {
    let (tx, mut rx) = tokio::sync::mpsc::channel(100);
    
    let mut watcher = watcher(move |res| {
        // Parse log lines into StreamEvents
    }, Duration::from_secs(1))?;
    
    watcher.watch("/var/log/trading", RecursiveMode::Recursive)?;
    
    while let Some(file_event) = rx.recv().await {
        let stream_event = parse_log_event(file_event);
        engine.send_event(stream_event).await?;
    }
}
```

### Use Case Examples

#### 📈 **Financial Trading**
```rust
rule "CircuitBreaker" {
    when
        priceMax > 200.0 || priceMin < 50.0
    then
        MarketService.halt("extreme_movement");
}
```

#### 🌡️ **IoT Monitoring**
```rust
rule "OverheatingAlert" {
    when
        temperatureAverage > 80.0 && WindowEventCount > 20
    then
        CoolingSystem.activate();
        AlertService.notify("overheating_detected");
}
```

#### 🛡️ **Fraud Detection**
```rust
rule "SuspiciousActivity" {
    when
        transactionCountSum > 10 && amountAverage > 1000.0
    then
        SecurityService.flag("potential_fraud");
        AccountService.freeze();
}
```

#### 📊 **E-commerce Analytics**
```rust
rule "FlashSaleOpportunity" {
    when
        viewCountSum > 1000 && conversionRateAverage < 0.02
    then
        PromotionService.trigger("flash_sale");
        InventoryService.prepare();
}
```

See [docs/STREAMING.md](docs/STREAMING.md) for complete documentation and examples.

## 📊 Advanced Analytics & Performance Monitoring (v0.3.0+)

Get deep insights into your rule engine performance with built-in analytics and monitoring:

### 🔧 Quick Analytics Setup

```rust
use rust_rule_engine::{RustRuleEngine, AnalyticsConfig, RuleAnalytics};

// Configure analytics for production use
let analytics_config = AnalyticsConfig {
    track_execution_time: true,
    track_memory_usage: true,
    track_success_rate: true,
    sampling_rate: 0.8,  // 80% sampling for high-volume production
    retention_period: Duration::from_secs(30 * 24 * 60 * 60), // 30 days
    max_recent_samples: 100,
};

// Enable analytics
let analytics = RuleAnalytics::new(analytics_config);
engine.enable_analytics(analytics);

// Execute rules - analytics automatically collected
let result = engine.execute(&facts)?;

// Access comprehensive insights
if let Some(analytics) = engine.analytics() {
    let stats = analytics.overall_stats();
    println!("Total executions: {}", stats.total_evaluations);
    println!("Average execution time: {:.2}ms", 
        stats.avg_execution_time.as_secs_f64() * 1000.0);
    println!("Success rate: {:.1}%", stats.success_rate);
    
    // Get optimization recommendations
    let recommendations = analytics.generate_recommendations();
    for rec in recommendations {
        println!("💡 {}", rec);
    }
}
```

## 🔄 No-Loop Protection

Prevent rules from infinitely triggering themselves - essential for rules that modify their own conditions:

### 🎯 The Problem

```grl
// ❌ Without no-loop: INFINITE LOOP!
rule "ScoreBooster" {
    when
        Player.score < 100
    then
        set(Player.score, Player.score + 10);  // This changes the condition!
}
// Rule keeps firing: 50 → 60 → 70 → 80 → 90 → 100 → STOP (only due to max_cycles)
```

### ✅ The Solution

```grl
// ✅ With no-loop: SAFE!
rule "ScoreBooster" no-loop {
    when
        Player.score < 100
    then
        set(Player.score, Player.score + 10);  // Rule fires once per cycle
}
// Rule fires once: 50 → 60, then waits for next cycle
```

### 🧪 Usage Examples

```rust
use rust_rule_engine::*;

// Method 1: Via GRL parsing
let grl = r#"
    rule "SafeUpdater" no-loop salience 10 {
        when Player.level < 5
        then set(Player.level, Player.level + 1);
    }
"#;
let rules = GRLParser::parse_rules(grl)?;

// Method 2: Via API
let rule = Rule::new("SafeUpdater".to_string(), conditions, actions)
    .with_no_loop(true)
    .with_salience(10);

// Method 3: Multiple positions supported
// rule "Name" no-loop salience 10 { ... }  ✅
// rule "Name" salience 10 no-loop { ... }  ✅
```

### 🔬 How It Works

1. **Per-Cycle Tracking**: Engine tracks which rules fired in current cycle
2. **Skip Logic**: Rules with `no_loop=true` skip if already fired this cycle  
3. **Fresh Start**: Tracking resets at beginning of each new cycle
4. **Drools Compatible**: Matches Drools behavior exactly

### 🎮 Real Example

```rust
fn demo_no_loop() -> Result<()> {
    let grl = r#"
        rule "LevelUp" no-loop {
            when Player.xp >= 100
            then 
                set(Player.level, Player.level + 1);
                set(Player.xp, 0);
                log("Player leveled up!");
        }
    "#;
    
    let rules = GRLParser::parse_rules(grl)?;
    // Rule fires once: level 1→2, xp 150→0
    // Without no-loop: would fire again since xp >= 100 still true initially
}
```

### 📈 Analytics Features

- **⏱️ Execution Timing**: Microsecond-precision rule performance tracking
- **📊 Success Rate Monitoring**: Track fired vs evaluated rule ratios  
- **💾 Memory Usage Estimation**: Optional memory footprint analysis
- **🎯 Performance Rankings**: Identify fastest and slowest rules
- **🔮 Smart Recommendations**: AI-powered optimization suggestions
- **📅 Timeline Analysis**: Recent execution history and trends
- **⚙️ Production Sampling**: Configurable sampling rates for high-volume environments
- **🗂️ Automatic Cleanup**: Configurable data retention policies

### 🎛️ Production Configuration

```rust
// Production configuration with optimized settings
let production_config = AnalyticsConfig::production(); // Built-in production preset

// Or custom configuration
let custom_config = AnalyticsConfig {
    track_execution_time: true,
    track_memory_usage: false,    // Disable for performance
    track_success_rate: true,
    sampling_rate: 0.1,          // 10% sampling for high traffic
    retention_period: Duration::from_secs(7 * 24 * 60 * 60), // 1 week
    max_recent_samples: 50,      // Limit memory usage
};
```

### 📊 Rich Analytics Dashboard

```rust
// Get comprehensive performance report
let analytics = engine.analytics().unwrap();

// Overall statistics
let stats = analytics.overall_stats();
println!("📊 Performance Summary:");
println!("  Rules: {}", stats.total_rules);
println!("  Executions: {}", stats.total_evaluations);
println!("  Success Rate: {:.1}%", stats.success_rate);
println!("  Avg Time: {:.2}ms", stats.avg_execution_time.as_secs_f64() * 1000.0);

// Top performing rules
for rule_metrics in analytics.slowest_rules(3) {
    println!("⚠️ Slow Rule: {} ({:.2}ms avg)", 
        rule_metrics.rule_name, 
        rule_metrics.avg_execution_time().as_secs_f64() * 1000.0
    );
}

// Recent activity timeline
for event in analytics.get_recent_events(5) {
    let status = if event.success { "✅" } else { "❌" };
    println!("{} {} - {:.2}ms", status, event.rule_name, 
        event.duration.as_secs_f64() * 1000.0);
}
```

### 🔍 Performance Insights

The analytics system provides actionable insights:

- **Slow Rule Detection**: "Consider optimizing 'ComplexValidation' - average execution time is 15.3ms"
- **Low Success Rate Alerts**: "Rule 'RareCondition' has low success rate (12.5%) - review conditions"  
- **Dead Rule Detection**: "Rule 'ObsoleteCheck' never fires despite 156 evaluations - review logic"
- **Memory Usage Warnings**: "Rule 'DataProcessor' uses significant memory - consider optimization"

### 📚 Analytics Examples

Check out the comprehensive analytics demo:

```bash
# Run the analytics demonstration
cargo run --example analytics_demo

# Output includes:
# - Configuration summary
# - Performance rankings  
# - Success rate analysis
# - Optimization recommendations
# - Recent execution timeline
```

**Key Benefits:**
- 🚀 **Performance Optimization**: Identify bottlenecks automatically
- 📈 **Production Monitoring**: Real-time insights in live environments
- 🔧 **Development Debugging**: Detailed execution analysis during development
- 📊 **Trend Analysis**: Historical performance tracking and regression detection
- ⚡ **Zero-Overhead Option**: Configurable sampling with minimal performance impact

## 🔧 RETE Algorithm Engine (NEW)

The Rust Rule Engine now includes **two complementary engines**:

1. **Native Engine** (`RustRuleEngine`) - Feature-rich, plugin-based engine
2. **RETE-UL Engine** (`IncrementalEngine`) - High-performance pattern matcher (~95% Drools parity)

**Choose based on your needs**:
- **< 50 rules, need plugins/analytics** → Use Native Engine
- **> 100 rules, need performance** → Use RETE-UL Engine
- **Both requirements** → Use Hybrid approach (both engines)

📖 See [ENGINE_COMPARISON.md](ENGINE_COMPARISON.md) for detailed comparison and recommendations.

### RETE-UL Engine Overview

A high-performance **RETE-UL (Unordered Linear) algorithm implementation** with **~97% feature parity** with [Drools](https://www.drools.org/) rule engine! This provides efficient pattern matching, incremental fact updates, advanced rule execution capabilities, and **CLIPS-inspired features** (Template System, Defglobal).

### 🎯 What is RETE?

RETE is a fast pattern matching algorithm for rule-based systems, widely used in production rule engines like Drools, Jess, and CLIPS. Our RETE-UL implementation provides:

- **Fast Pattern Matching**: Efficient evaluation of complex rule conditions
- **Incremental Updates**: Only re-evaluate affected rules when facts change
- **Working Memory**: Drools-style fact management with FactHandles
- **Advanced Agenda**: Priority-based rule execution with agenda groups
- **Variable Binding**: Cross-pattern variable sharing ($var syntax)
- **Multi-Object Patterns**: JOIN facts across multiple types

### 🚀 Key Features

#### 1. **Typed Facts System** 📦

Strongly-typed fact system supporting multiple data types:

```rust
use rust_rule_engine::rete::{TypedFacts, FactValue};

let mut facts = TypedFacts::new();
facts.set("name", "John Smith");           // String
facts.set("age", 30i64);                   // Integer
facts.set("salary", 50000.0);              // Float
facts.set("is_active", true);              // Boolean
facts.set("tags", vec!["vip", "premium"]); // Array

// Advanced operators
facts.evaluate_condition("name", "contains", &FactValue::String("John".to_string()));
facts.evaluate_condition("age", ">", &FactValue::Integer(18));
facts.evaluate_condition("tags", "in", &FactValue::String("vip".to_string()));
```

**Supported Operators:**
- Comparison: `==`, `!=`, `>`, `>=`, `<`, `<=`
- String: `contains`, `startsWith`, `endsWith`, `matches` (wildcard)
- Array: `in` (membership check)

#### 2. **Working Memory with FactHandles** 🧠

Drools-style fact management:

```rust
use rust_rule_engine::rete::{WorkingMemory, TypedFacts};

let mut wm = WorkingMemory::new();

// Insert fact
let mut person = TypedFacts::new();
person.set("name", "Alice");
person.set("age", 30i64);
let handle = wm.insert("Person".to_string(), person);

// Update fact
let mut updated = TypedFacts::new();
updated.set("name", "Alice");
updated.set("age", 31i64);
wm.update(handle, updated).unwrap();

// Retract fact
wm.retract(handle).unwrap();

// Query by type
let persons = wm.get_by_type("Person");
```

**Features:**
- ✅ Unique FactHandle for each fact (like Drools)
- ✅ Insert/Update/Retract operations
- ✅ Type indexing for fast lookups (~4µs per insert)
- ✅ Change tracking (modified/retracted facts)
- ✅ Fact metadata (timestamps, update counts)

#### 3. **Advanced Agenda Control** 📋

Full Drools-style agenda features:

```rust
use rust_rule_engine::rete::{Activation, AdvancedAgenda};

let activation = Activation::new("HighPriorityRule".to_string(), 10)
    .with_salience(100)                    // Priority
    .with_activation_group("validators")   // Only one fires per group
    .with_agenda_group("validation")       // Sequential execution
    .with_auto_focus(true)                 // Auto-switch to this group
    .with_no_loop(true)                    // Prevent infinite loops
    .with_lock_on_active(true);            // Lock during execution

let mut agenda = AdvancedAgenda::new();
agenda.add_activation(activation);
agenda.set_focus("validation");

// Get next activation (respects salience)
if let Some(act) = agenda.get_next_activation() {
    println!("Firing: {}", act.rule_name);
}
```

**Agenda Features:**
| Feature | Description | Status |
|---------|-------------|--------|
| Salience/Priority | Order rules by priority | ✅ |
| Activation Groups | Only one rule fires per group | ✅ |
| Agenda Groups | Sequential execution phases | ✅ |
| Ruleflow Groups | Workflow-based execution | ✅ |
| Auto-Focus | Automatic group switching | ✅ |
| No-Loop | Prevent infinite loops | ✅ |
| Lock-on-Active | Prevent re-activation | ✅ |

#### 4. **Variable Binding & Multi-Pattern Matching** 🔗

Drools-style pattern matching with variable binding:

```rust
use rust_rule_engine::rete::{PatternBuilder, MultiPattern, WorkingMemory, FactValue};

let mut wm = WorkingMemory::new();

// Insert facts
let mut john = TypedFacts::new();
john.set("name", "John");
john.set("age", 30i64);
wm.insert("Person".to_string(), john);

let mut order = TypedFacts::new();
order.set("customer", "John");
order.set("amount", 1500.0);
wm.insert("Order".to_string(), order);

// Pattern 1: Bind $name from Person
let person_pattern = PatternBuilder::for_type("Person")
    .bind("name", "$name")                      // Bind to $name
    .where_field("age", ">", FactValue::Integer(18))
    .build();

// Pattern 2: Use $name in Order
let order_pattern = PatternBuilder::for_type("Order")
    .where_var("customer", "==", "$name")       // Use bound $name
    .where_field("amount", ">", FactValue::Float(1000.0))
    .build();

// Multi-pattern JOIN
let multi = MultiPattern::new("HighValueCustomers".to_string())
    .with_pattern(person_pattern)
    .with_pattern(order_pattern);

// Find matching combinations
let matches = multi.match_all(&wm);
for (handles, bindings) in matches {
    println!("Customer: {}", bindings.get("$name").unwrap());
    // Found: John (Person) with high-value Order
}
```

**Drools Comparison:**

```java
// Drools DRL
rule "HighValueCustomers"
when
    $p: Person($name: name, age > 18)
    $o: Order(customer == $name, amount > 1000)
then
    // Action
end
```

```rust
// Equivalent Rust RETE-UL (shown above)
```

**Pattern Features:**
- ✅ Variable binding: `$var` syntax
- ✅ Cross-pattern joins: Share variables between patterns
- ✅ Multi-object matching: 2-way, 3-way, N-way joins
- ✅ Complex constraints: `field op $var`

#### 5. **Incremental Propagation** ⚡

Only re-evaluate affected rules when facts change:

```rust
use rust_rule_engine::rete::{IncrementalEngine, TypedReteUlRule, ReteUlNode, AlphaNode};

let mut engine = IncrementalEngine::new();

// Add rules with dependencies
let person_rule = TypedReteUlRule {
    name: "IsAdult".to_string(),
    node: ReteUlNode::UlAlpha(AlphaNode {
        field: "Person.age".to_string(),
        operator: ">".to_string(),
        value: "18".to_string(),
    }),
    priority: 10,
    no_loop: true,
    action: Box::new(|facts| {
        facts.set("is_adult", true);
    }),
};

let order_rule = TypedReteUlRule {
    name: "HighValueOrder".to_string(),
    node: ReteUlNode::UlAlpha(AlphaNode {
        field: "Order.amount".to_string(),
        operator: ">".to_string(),
        value: "1000".to_string(),
    }),
    priority: 5,
    no_loop: true,
    action: Box::new(|facts| {
        facts.set("high_value", true);
    }),
};

// Register dependencies
engine.add_rule(person_rule, vec!["Person".to_string()]);
engine.add_rule(order_rule, vec!["Order".to_string()]);

// Insert Person - only person_rule evaluated! ⚡
let mut person = TypedFacts::new();
person.set("age", 25i64);
let handle = engine.insert("Person".to_string(), person);

// Fire rules - only IsAdult fires
let fired = engine.fire_all();
println!("Fired: {:?}", fired);  // ["IsAdult"]

// Update Person - only person_rule re-evaluated! ⚡
let mut updated = TypedFacts::new();
updated.set("age", 17i64);
engine.update(handle, updated).unwrap();
```

**Performance Benefits:**
- 🚀 **2x faster**: Only 50% of rules evaluated (in above example)
- ⚡ **~35µs per update**: Ultra-fast incremental updates
- 📈 **Scales linearly**: With affected rules, not total rules
- 🎯 **Automatic optimization**: Transparent dependency tracking

**Drools Comparison:**
```java
// Drools
kieSession.update(handle, fact);  // ✓ Only affected rules!
```

```rust
// Rust RETE-UL
engine.update(handle, fact)?;     // ✓ Only affected rules!
```

#### 6. **Memoization & Caching** 💾

Performance optimization through evaluation caching:

```rust
use rust_rule_engine::rete::{MemoizedEvaluator, ReteUlNode, TypedFacts};

let mut evaluator = MemoizedEvaluator::new();

// First evaluation - cache miss
let result1 = evaluator.evaluate(&node, &facts, |n, f| {
    // Expensive evaluation here
    n.matches_typed(f)
});

// Second evaluation - cache HIT! ⚡
let result2 = evaluator.evaluate(&node, &facts, |n, f| {
    n.matches_typed(f)
});

// Get statistics
let stats = evaluator.stats();
println!("Cache hit rate: {:.2}%", stats.hit_rate * 100.0);
// Output: Cache hit rate: 99.99%
```

**Performance:**
- 📊 **99.99% hit rate**: In optimal scenarios
- 🚀 **5-20x speedup**: For repeated evaluations
- 💾 **Minimal overhead**: Hash-based cache

#### 7. **Template System (CLIPS-inspired)** 📋✨

Type-safe schema definitions for structured facts (similar to CLIPS deftemplate):

```rust
use rust_rule_engine::rete::{TemplateBuilder, FieldType, FactValue, IncrementalEngine};

let mut engine = IncrementalEngine::new();

// Define template with typed fields
let person_template = TemplateBuilder::new("Person")
    .required_string("name")           // Required field
    .integer_field("age")              // Optional with default
    .boolean_field("is_adult")         // Optional with default
    .float_field("salary")             // Optional with default
    .array_field("skills", FieldType::String)  // Array field
    .build();

// Register template
engine.templates_mut().register(person_template);

// Create validated fact
let mut person = TypedFacts::new();
person.set("name", FactValue::String("Alice".to_string()));
person.set("age", FactValue::Integer(30));
person.set("is_adult", FactValue::Boolean(true));

// Insert with automatic validation ✅
let handle = engine.insert_with_template("Person", person)?;
// Validation error if required fields missing or wrong type!
```

**Benefits:**
- ✅ **Type Safety**: Catch type errors at insertion time
- ✅ **Schema Validation**: Required fields and type checking
- ✅ **Default Values**: Automatic defaults for missing fields
- ✅ **Documentation**: Templates serve as living schema documentation
- 🎯 **CLIPS-compatible**: Similar to CLIPS deftemplate feature

#### 8. **Defglobal (Global Variables)** 🌍✨

Persistent global variables across rule firings (CLIPS-inspired):

```rust
use rust_rule_engine::rete::{IncrementalEngine, FactValue};

let mut engine = IncrementalEngine::new();

// Define global variables
engine.globals().define("orders_count", FactValue::Integer(0))?;
engine.globals().define("total_revenue", FactValue::Float(0.0))?;

// Read-only constants
engine.globals().define_readonly("MAX_RETRIES", FactValue::Integer(3))?;
engine.globals().define_readonly("VERSION", FactValue::String("1.0.0".to_string()))?;

// Access and modify
let count = engine.globals().get("orders_count")?;
engine.globals().set("orders_count", FactValue::Integer(5))?;

// Convenient increment for counters
engine.globals().increment("orders_count", 1.0)?;
engine.globals().increment("total_revenue", 150.0)?;

// Thread-safe via Arc<RwLock>
```

**Benefits:**
- ✅ **State Persistence**: Maintain state across rule firings
- ✅ **Counters & Stats**: Easy tracking of aggregates
- ✅ **Constants**: Read-only global configuration
- ✅ **Thread-Safe**: Built-in Arc<RwLock> safety
- 🎯 **CLIPS-compatible**: Similar to CLIPS defglobal feature

📖 **See [CLIPS_INSPIRED_FEATURES.md](CLIPS_INSPIRED_FEATURES.md) for complete documentation and examples.**

### 📊 Feature Comparison: Rust RETE-UL vs Drools

| Feature Category | Feature | Drools | Rust RETE-UL |
|------------------|---------|--------|--------------|
| **Core Algorithm** | RETE Network | ✓ | ✓ (RETE-UL) |
| | AND/OR/NOT | ✓ | ✓ |
| | EXISTS/FORALL | ✓ | ✓ |
| **Type System** | Typed Facts | ✓ | ✓ |
| | Multiple Types | ✓ | ✓ |
| **Operators** | Comparison | ✓ | ✓ |
| | String Ops | ✓ | ✓ |
| | Set Membership | ✓ | ✓ |
| **Working Memory** | FactHandles | ✓ | ✓ |
| | Insert/Update/Retract | ✓ | ✓ |
| | Type Indexing | ✓ | ✓ |
| **Agenda** | Salience | ✓ | ✓ |
| | Activation Groups | ✓ | ✓ |
| | Agenda Groups | ✓ | ✓ |
| | No-Loop | ✓ | ✓ |
| **Pattern Matching** | Variable Binding | ✓ | ✓ |
| | Multi-Object | ✓ | ✓ |
| | Cross-Pattern Joins | ✓ | ✓ |
| **Performance** | Incremental Updates | ✓ | ✓ |
| | Memoization | ✓ | ✓ |
| | Node Caching | ✓ | ✓ |
| **CLIPS Features** | Template System | ✓ (declare) | ✓ (NEW!) |
| | Defglobal | ✓ (global) | ✓ (NEW!) |

**Overall Coverage**: **~97% feature parity** with Drools core engine! 🎉✨

**New in v0.10.0**: Template System and Defglobal inspired by CLIPS!

### 🎯 Performance Metrics

#### Node Caching
- **Speedup**: 2-10x faster than rebuilding nodes
- **Use Case**: Repeated rule evaluations

#### Memoization
- **Cache Hit Rate**: 99.99% (optimal scenarios)
- **Speedup**: 5-20x for repeated patterns
- **Overhead**: Minimal (hash-based)

#### Working Memory
- **Insert**: ~4µs per fact (1000 facts)
- **Type Lookup**: O(1) with indexing
- **Update Tracking**: Constant time

#### Incremental Propagation
- **Update Time**: ~35µs per update (20 rules)
- **Efficiency**: 2x speedup (selective evaluation)
- **Scalability**: Linear with affected rules

### 📚 Examples

Run comprehensive RETE examples:

```bash
# Working Memory & FactHandles
cargo run --example rete_p2_working_memory

# Advanced Agenda Control
cargo run --example rete_p2_advanced_agenda

# Variable Binding & Pattern Matching
cargo run --example rete_p3_variable_binding

# Incremental Propagation
cargo run --example rete_p3_incremental

# Typed Facts & Operators
cargo run --example rete_typed_facts_demo

# Memoization Performance
cargo run --example rete_memoization_demo
```

### 🔍 Use Cases

**1. Complex Business Rules**

Detect high-value customers with recent orders using multi-pattern matching:

```rust
use rust_rule_engine::rete::{GrlReteLoader, IncrementalEngine};

let grl = r#"
rule "HighValueCustomerDetection" salience 20 no-loop {
    when
        Customer.total_spent > 10000 &&
        Customer.orders_count > 50 &&
        exists(Order.amount > 1000)
    then
        Customer.tier = "VIP";
        Customer.discount = 0.25;
        Customer.priority_support = true;
}

rule "VIPOrderProcessing" salience 15 no-loop {
    when
        Customer.tier == "VIP" && Order.amount > 500
    then
        Order.fast_shipping = true;
        Order.priority_handling = true;
}
"#;

let mut engine = IncrementalEngine::new();
GrlReteLoader::load_from_string(grl, &mut engine)?;

// Insert facts and fire rules
let mut customer = TypedFacts::new();
customer.set("total_spent", 15000.0);
customer.set("orders_count", 75i64);
engine.insert("Customer".to_string(), customer);

let fired = engine.fire_all();
// Only affected rules fire incrementally!
```

**2. Real-Time Systems**

Stream processing with incremental updates - only re-evaluate affected rules:

```rust
use rust_rule_engine::rete::{IncrementalEngine, TypedFacts, GrlReteLoader};

// Load streaming rules
let rules = r#"
rule "HighFrequencyTrading" salience 25 no-loop {
    when
        Stock.price > 100.0 && Stock.change_percent > 5.0
    then
        Alert.trading_signal = "BUY";
}

rule "AnomalyDetection" salience 30 no-loop {
    when
        Transaction.amount > 10000 && Transaction.frequency > 10
    then
        Alert.anomaly_detected = true;
        Alert.investigate = true;
}
"#;

let mut engine = IncrementalEngine::new();
GrlReteLoader::load_from_string(rules, &mut engine)?;

// Stream updates - only affected rules evaluated!
for event in event_stream {
    let mut fact = TypedFacts::new();
    fact.set("price", event.price);
    fact.set("change_percent", event.change);

    // Incremental: Only Stock-dependent rules re-evaluated
    let handle = engine.insert("Stock".to_string(), fact);

    // Update existing fact - still only affected rules!
    let mut updated = TypedFacts::new();
    updated.set("price", event.new_price);
    engine.update(handle, updated)?;
}

// Performance: ~35µs per update with incremental propagation
```

**3. Workflow Engines**

Sequential workflow phases using agenda groups:

```rust
use rust_rule_engine::rete::{IncrementalEngine, GrlReteLoader, TypedFacts};

let workflow_rules = r#"
rule "Phase1_Validation" salience 30 no-loop {
    when
        Order.status == "new" && Order.amount > 0
    then
        Order.validation_passed = true;
        Order.status = "validated";
}

rule "Phase2_ApprovalCheck" salience 20 no-loop {
    when
        Order.status == "validated" && Order.amount > 1000
    then
        Order.requires_approval = true;
        Order.status = "pending_approval";
}

rule "Phase3_Processing" salience 10 no-loop {
    when
        Order.status == "pending_approval" &&
        forall(Approval.status == "approved")
    then
        Order.status = "processing";
        Order.ready_to_ship = true;
}

rule "Phase4_Completion" salience 5 no-loop {
    when
        Order.status == "processing" && Order.shipped == true
    then
        Order.status = "completed";
}
"#;

let mut engine = IncrementalEngine::new();
GrlReteLoader::load_from_string(workflow_rules, &mut engine)?;

// Execute workflow phases sequentially
let mut order = TypedFacts::new();
order.set("status", "new");
order.set("amount", 1500.0);
let handle = engine.insert("Order".to_string(), order);

// Each phase triggers next phase
engine.fire_all();

// Update to progress workflow
let mut updated = TypedFacts::new();
updated.set("status", "validated");
updated.set("amount", 1500.0);
engine.update(handle, updated)?;

engine.reset();
engine.fire_all();
```

**4. Expert Systems**

Variable binding for reasoning about relationships:

```rust
use rust_rule_engine::rete::{PatternBuilder, MultiPattern, WorkingMemory, TypedFacts, FactValue};

let mut wm = WorkingMemory::new();

// Insert domain knowledge
let mut person = TypedFacts::new();
person.set("name", "Dr. Smith");
person.set("expertise", "cardiology");
person.set("years_experience", 15i64);
wm.insert("Doctor".to_string(), person);

let mut patient = TypedFacts::new();
patient.set("name", "John Doe");
patient.set("condition", "heart disease");
patient.set("assigned_doctor", "");
wm.insert("Patient".to_string(), patient);

let mut diagnosis = TypedFacts::new();
diagnosis.set("patient_id", "P123");
diagnosis.set("type", "cardiology");
diagnosis.set("severity", "high");
wm.insert("Diagnosis".to_string(), diagnosis);

// Pattern: Match doctor expertise with patient condition
let doctor_pattern = PatternBuilder::for_type("Doctor")
    .bind("name", "$doctorName")
    .bind("expertise", "$expertise")
    .where_field("years_experience", ">", FactValue::Integer(10))
    .build();

let diagnosis_pattern = PatternBuilder::for_type("Diagnosis")
    .where_var("type", "==", "$expertise")  // Match expertise
    .where_field("severity", "==", FactValue::String("high".to_string()))
    .bind("patient_id", "$patientId")
    .build();

let patient_pattern = PatternBuilder::for_type("Patient")
    .bind("name", "$patientName")
    .build();

// Multi-pattern reasoning: Doctor + Diagnosis + Patient
let expert_system = MultiPattern::new("OptimalAssignment".to_string())
    .with_pattern(doctor_pattern)
    .with_pattern(diagnosis_pattern)
    .with_pattern(patient_pattern);

// Find optimal doctor-patient assignments
let matches = expert_system.match_all(&wm);

for (_handles, bindings) in matches {
    println!("Expert System Decision:");
    println!("  Assign patient: {}", bindings.get("$patientName").unwrap());
    println!("  To doctor: {}", bindings.get("$doctorName").unwrap());
    println!("  Based on expertise: {}", bindings.get("$expertise").unwrap());
    // Output: Dr. Smith (cardiology) → John Doe (heart disease)
}
```

### 📖 Documentation

For complete implementation details, see:
- [RETE_DROOLS_IMPROVEMENTS.md](RETE_DROOLS_IMPROVEMENTS.md) - Full feature documentation
- [src/rete/](src/rete/) - Implementation source code
- [examples/rete_*.rs](examples/) - Comprehensive examples

### 🎓 Learn More

- [Drools Documentation](https://docs.drools.org/)
- [RETE Algorithm Paper](https://cse.sc.edu/~mgv/csce582sp15/gradPres/Rete_presentation.pdf)
- [RETE-UL: An Improvement on RETE](https://arxiv.org/abs/cs/0202030)

**Status**: ✅ Production-ready with 26/26 tests passing

## 📋 Changelog

### v0.3.0 (October 2025) - AST-Based Dependency Analysis & Advanced Analytics
- **🔍 Revolutionary Dependency Analysis**: Complete rewrite from hard-coded pattern matching to proper AST parsing
- **🎯 Smart Field Detection**: Recursive condition tree traversal for accurate field dependency extraction
- **🧠 Function Side-Effect Analysis**: Intelligent inference of field modifications from function calls
- **⚡ Zero False Positives**: Elimination of brittle string-based detection methods
- **🚀 Parallel Processing Foundation**: AST-based analysis enables safe concurrent rule execution
- **📊 Advanced Conflict Detection**: Real data flow analysis for read-write conflict identification
- **🏗️ Production-Ready Safety**: Robust dependency analysis for enterprise-grade rule management
- **📈 Advanced Analytics System**: Comprehensive performance monitoring and optimization insights
  - Real-time execution metrics with microsecond precision
  - Success rate tracking and trend analysis
  - Memory usage estimation and optimization recommendations
  - Production-ready sampling and data retention policies
  - Automated performance optimization suggestions
  - Rich analytics dashboard with timeline analysis
- **🌐 REST API with Monitoring**: Production-ready web API with full analytics integration
  - Comprehensive REST endpoints for rule execution
  - Real-time analytics dashboard with performance insights
  - Health monitoring and system status endpoints
  - CORS support and proper error handling
  - Sample requests and complete API documentation

### v0.2.x - Core Features & Streaming
- **🌊 Stream Processing**: Real-time event processing with time windows
- **📊 Rule Templates**: Parameterized rule generation system
- **🔧 Method Calls**: Enhanced object method call support
- **📄 File-Based Rules**: External `.grl` file support
- **⚡ Performance Optimizations**: Microsecond-level rule execution

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 📞 Support

- 📚 **Documentation**: [docs.rs/rust-rule-engine](https://docs.rs/rust-rule-engine)
- 🐛 **Issues**: [GitHub Issues](https://github.com/KSD-CO/rust-rule-engine/issues)
- 💬 **Discussions**: [GitHub Discussions](https://github.com/KSD-CO/rust-rule-engine/discussions)

---

**Built with ❤️ in Rust** 🦀
